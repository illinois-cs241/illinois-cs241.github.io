<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>CS 341 · Networking</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <!-- For table of content  -->

  <link rel="stylesheet" href="/css/code-style.css"/>
  <link rel="stylesheet" href="/css/main.css"/>
  <link rel="stylesheet" href="/css/bootstrap-toc.css"/>

  <meta property="og:locale" content="en_US">

  
  <meta property="og:title" content="Networking" />
  

  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://cs341.cs.illinois.edu" />

  
  <meta property="og:description" content=""Webpage for CS 341: System Programming at the University of Illinois Urbana-Champaign. All documentation and information about the course can be found here."
" />
  

</head>


<body data-spy="scroll" data-target="#overview" data-offset="50">
  <div class="container-fluid">
    <div class="row" style="display: flex; justify-content: stretch;">
      <!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <!-- Navigation button as html so we don't have to resize images -->
      <button
        type="button"
        class="navbar-toggle collapsed"
        data-toggle="collapse"
        data-target=".navbar-collapse"
        aria-expanded="false"
        aria-controls="navbar"
      >
        <!-- Hamburger Navigation bar on small -->
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Full title on laptop -->
      <a class="navbar-brand navbar-item normal" href="/">
             <span>CS 341: System Programming</span> 
      </a>

      <!-- Smaller on mobile-->
      <a class="navbar-brand navbar-item small" href="/">
          <span>CS 341</span>
      </a>
    </div>

    <!-- Finally generate what is in the navbar -->
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
        <li class="navbar-item">
          <a href="/assignments.html">Assignments</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/quiz_topics.html">Quizzes</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/grades.html">Grades</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/schedule.html">Lectures</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/syllabus.html">Syllabus</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/staff.html">Staff</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/resources.html">Resources</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="/peer_tutoring.html">Peer Tutoring</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/coursebook/index.html">Coursebook</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="">Lecture Materials</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/tutorials/development">Linux Virtual Machine</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/honors.html">Honors</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
      </ul>
    </div>
  </div>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Roboto"
    rel="stylesheet"
  />
</nav>

      <div class="row">
        <div class="col-sm-3 col-xs-12 hidden-xs" style="min-height: 100%">
          <nav id="overview" data-toggle="toc" class="sticky-top"></nav>
        </div>
        <div class="col-sm-9 col-xs-12">
          <div class="title">
            
            
            
            <h1>
              Networking
            </h1>
          </div>
          <div class="content col-sm-11 .col-sm-offset-1">
            
          </div>
          <div class="hidden-sm hidden-md hidden-lg">
            
          </div>
          <div id="content">
            


            <div class="wrapper">
<ul>
  <li>
<a href="#networking" class="fancy-link wiki-link">Networking</a>
    <ul>
      <li><a href="#the-osi-model" class="fancy-link wiki-link">The OSI Model</a></li>
      <li>
<a href="#layer-3-the-internet-protocol" class="fancy-link wiki-link">Layer 3: The Internet Protocol</a>
        <ul>
          <li><a href="#whats-the-deal-with-ipv6" class="fancy-link wiki-link">What’s the deal with IPv6?</a></li>
          <li><a href="#whats-my-address" class="fancy-link wiki-link">What’s My Address?</a></li>
        </ul>
      </li>
      <li>
<a href="#layer-4-tcp-and-client" class="fancy-link wiki-link">Layer 4: TCP and Client</a>
        <ul>
          <li><a href="#note-on-network-orders" class="fancy-link wiki-link">Note on network orders</a></li>
          <li><a href="#tcp-client" class="fancy-link wiki-link">TCP Client</a></li>
          <li><a href="#sending-some-data" class="fancy-link wiki-link">Sending some data</a></li>
        </ul>
      </li>
      <li>
<a href="#layer-4-tcp-server" class="fancy-link wiki-link">Layer 4: TCP Server</a>
        <ul>
          <li><a href="#example-server" class="fancy-link wiki-link">Example Server</a></li>
          <li><a href="#sorry-to-interrupt" class="fancy-link wiki-link">Sorry To Interrupt</a></li>
        </ul>
      </li>
      <li>
<a href="#layer-4-udp" class="fancy-link wiki-link">Layer 4: UDP</a>
        <ul>
          <li><a href="#udp-attributes" class="fancy-link wiki-link">UDP Attributes</a></li>
          <li><a href="#udp-client" class="fancy-link wiki-link">UDP Client</a></li>
          <li><a href="#udp-server" class="fancy-link wiki-link">UDP Server</a></li>
        </ul>
      </li>
      <li>
<a href="#layer-7-http" class="fancy-link wiki-link">Layer 7: HTTP</a>
        <ul>
          <li><a href="#whats-my-name" class="fancy-link wiki-link">What’s my name?</a></li>
        </ul>
      </li>
      <li>
<a href="#non-blocking-io" class="fancy-link wiki-link">Non-Blocking IO</a>
        <ul>
          <li><a href="#epoll" class="fancy-link wiki-link">epoll</a></li>
          <li><a href="#epoll-example" class="fancy-link wiki-link">Epoll Example</a></li>
          <li><a href="#assorted-epoll-gotchas" class="fancy-link wiki-link">Assorted Epoll Gotchas</a></li>
        </ul>
      </li>
      <li>
<a href="#remote-procedure-calls" class="fancy-link wiki-link">Remote Procedure Calls</a>
        <ul>
          <li><a href="#privilege-separation" class="fancy-link wiki-link">Privilege Separation</a></li>
          <li><a href="#stub-code-and-marshaling" class="fancy-link wiki-link">Stub Code and Marshaling</a></li>
          <li><a href="#interface-description-language" class="fancy-link wiki-link">Interface Description
Language</a></li>
          <li><a href="#transferring-structured-data" class="fancy-link wiki-link">Transferring Structured
Data</a></li>
        </ul>
      </li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p><span> </span></p>



<p><strong>The Web as I envisaged it, we have not seen it yet. The future is
still so much bigger than the past</strong> - <strong>Tim Berners-Lee</strong></p>

<p>Networking has become arguably the most important use of computers in
the past 10-20 years. Most of us nowadays can’t stand a place without
WiFi or any connectivity, so it is crucial as programmers that you have
an understanding of networking and how to program to communicate across
networks. Although it may sound complicated, POSIX has defined nice
standards that make connecting to the outside world easy. POSIX also
lets you peer underneath the hood and optimize all the little parts of
each connection to write highly performant programs.</p>

<p>As an addendum that you’ll read more about in the next chapter, we will
be strict in our notation for sizes. That means that when we refer to
the SI prefixes of Kilo-, Mega-, etc, then we are always referring to a
power of 10. A kilobyte is one thousand bytes, a megabyte is a thousand
kilobytes and so on. If we need to refer to <code class="language-plaintext highlighter-rouge">1024</code> bytes, we will use
the more accurate term Kibibyte. Mibibyte and Gibibyte are the analogs
of Megabyte and Gigabyte respectively. We make this distinction to make
sure that we aren’t off by 24. The reasons for this misnomer will be
explained in the filesystems chapter.</p>

<div class="pad"><div class="card">
<div class="title"><h2 id="the-osi-model" class="title-text">The OSI Model<a class="anchor title-text" href="#the-osi-model"> #</a>
</h2></div>







<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The Open Source Interconnection 7 layer model (OSI Model) is a sequence
of segments that define standards for both infrastructure and protocols
for forms of radio communication, in our case the Internet. The 7 layer
model is as follows</p>
<ol>
  <li>
    <p>Layer 1: The Physical Layer. These are the actual waves that carry
the bauds across the wire. As an aside, bits don’t cross the wire
because in most mediums you can alter two characteristics of a wave
– the amplitude and the frequency – and get more bits per clock
cycle.</p>
  </li>
  <li>
    <p>Layer 2: The Link Layer. This is how each of the agents reacts to
certain events (error detection, noisy channels, etc). This is where
Ethernet and WiFi live.</p>
  </li>
  <li>
    <p>Layer 3: The Network Layer. This is the heart of the Internet. The
bottom two protocols deal with communication between two different
computers that are directly connected. This layer deals with routing
packets from one endpoint to another.</p>
  </li>
  <li>
    <p>Layer 4: The Transport Layer. This layer specifies how the slices of
data are received. The bottom three layers make no guarantee about
the order that packets are received and what happens when a packet
is dropped. Using different protocols, this layer can.</p>
  </li>
  <li>
    <p>Layer 5: The Session Layer. This layer makes sure that if a
connection in the previous layers is dropped, a new connection in
the lower layers can be established, and it looks like nothing
happened to the end-user.</p>
  </li>
  <li>
    <p>Layer 6: The Presentation Layer. This layer deals with encryption,
compression, and data translation. For example, portability between
different operating systems like translating newlines to windows
newlines.</p>
  </li>
  <li>
    <p>Layer 7: The Application Layer. HTTP and FTP are both defined at
this level. This is typically where we define protocols across the
Internet. As programmers, we only go lower when we think we can
create algorithms that are more suited to our needs than all of the
below.</p>
  </li>
</ol>
<p>This book won’t cover networking in depth. We will focus on some aspects
of layers 3, 4, and 7 because they are essential to know if you are
going to be doing something with the Internet, which at some point in
your career you will be. As for another definition, a protocol is a set
of specifications put forward by the Internet Engineering Task Force
that govern how implementers of a protocol have their program or circuit
behave under specific circumstances.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="layer-3-the-internet-protocol" class="title-text">Layer 3: The Internet Protocol<a class="anchor title-text" href="#layer-3-the-internet-protocol"> #</a>
</h2></div>





















































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The following is a short introduction to internet protocol (IP), the
primary way to send datagrams of information from one machine to
another. “IP4”, or more precisely, IPv4 is version 4 of the Internet
Protocol that describes how to send packets of information across a
network from one machine to another. Even as of 2018, IPv4 still
dominates Internet traffic, but google reports that 24 countries now
supply 15% of their traffic through IPv6 (“State of Ipv6 Deployment
2018”
<a href="#ref-internet_society_2018" class="fancy-link wiki-link">#ref-internet_society_2018</a>). A
significant limitation of IPv4 is that source and destination addresses
are limited to 32 bits. IPv4 was designed at a time when the idea of 4
billion devices connected to the same network was unthinkable or at
least not worth making the packet size larger. IPv4 addresses are
written typically in a sequence of four octets delimited by periods
“255.255.255.0” for example.</p>
<p>Each IPv4 datagram includes a small header - typically 20 octets, that
includes a source and destination address. Conceptually the source and
destination addresses can be split into two: a network number the upper
bits and lower bits represent a particular host number on that network.</p>
<p>A newer packet protocol IPv6 solves many of the limitations of IPv4 like
making routing tables simpler and 128-bit addresses. However, little web
traffic is IPv6 based on comparison as of 2018 (“State of Ipv6
Deployment 2018”
<a href="#ref-internet_society_2018" class="fancy-link wiki-link">#ref-internet_society_2018</a>) We
write IPv6 addresses in a sequence of eight, four hexadecimal delimiters
like “1F45:0000:0000:0000:0000:0000:0000:0000”. Since that can get
unruly, we can omit the zeros “1F45::”. A machine can have an IPv6
address and an IPv4 address.</p>
<p>There are special IP Addresses. One such in IPv4 is <code class="language-plaintext highlighter-rouge">127.0.0.1</code>, IPv6 as
<code class="language-plaintext highlighter-rouge">0:0:0:0:0:0:0:1</code> or <code class="language-plaintext highlighter-rouge">::1</code> also known as localhost. Packets sent to
127.0.0.1 will never leave the machine; the address is specified to be
the same machine. There are a lot of others that are denoted by certain
octets being zeros or 255, the maximum value. You won’t need to know all
the terminology, keep in mind that the actual number of IP addresses
that a machine can have globally over the Internet is smaller than the
number of “raw” addresses. This book covers how IP deals with routing,
fragmenting, and reassembling upper-level protocols. A more in-depth
aside follows.</p>
<h3 id="whats-the-deal-with-ipv6" class="title-text">What’s the deal with IPv6?</h3>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/networking/drawings/ipv6_datagram.png" alt="IPv6 Datagram
divisibility"></p>
<p>One of the big features of IPv6 is the address space. The world ran out
of IP addresses a while ago and has been using hacks to get around that.
With IPv6 there are enough internal and external addresses so even if we
discover alien civilizations, we probably won’t run out. The other
benefit is that these addresses are leased not bought, meaning that if
something drastic happens in let’s say the Internet of things and there
needs to be a change in the block addressing scheme, it can be done.</p>
<p>Another big feature is security through IPsec. IPv4 was designed with
little to no security in mind. As such, now there is a key exchange
similar to TLS in higher layers that allows you to encrypt
communication.</p>
<p>Another feature is simplified processing. To make the Internet fast,
IPv4 and IPv6 headers are verified in hardware. That means that all
header options are processed in circuits as they come in. The problem is
that as the IPv4 spec grew to include a copious amount of headers, the
hardware had to become more and more advanced to support those headers.
IPv6 reorders the headers so that packets can be dropped and routed with
fewer hardware cycles. In the case of the Internet, every cycle matters
when trying to route the world’s traffic.</p>
<h3 id="whats-my-address" class="title-text">What’s My Address?</h3>
<p>To obtain a linked list of IP addresses of the current machine use
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getifaddrs.3.html" class="fancy-link">getifaddrs</a></code> which will return a linked list of IPv4 and IPv6 IP
addresses among other interfaces as well. We can examine each entry and
use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getnameinfo.3p.html" class="fancy-link">getnameinfo</a></code> to print the host’s IP address. The <code class="language-plaintext highlighter-rouge">ifaddrs</code> struct
includes the family but does not include the sizeof the struct.
Therefore we need to manually determine the struct sized based on the
family.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">)</span> <span class="o">:</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span><span class="p">)</span>
</code></pre></div></div>
<p>The complete code is shown below.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">required_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span> <span class="c1">// Change to AF_INET6 for IPv6</span>
<span class="k">struct</span> <span class="n">ifaddrs</span> <span class="o">*</span><span class="n">myaddrs</span><span class="p">,</span> <span class="o">*</span><span class="n">ifa</span><span class="p">;</span>
<span class="n">getifaddrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myaddrs</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">host</span><span class="p">[</span><span class="mi">256</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="k">for</span> <span class="p">(</span><span class="n">ifa</span> <span class="o">=</span> <span class="n">myaddrs</span><span class="p">;</span> <span class="n">ifa</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ifa</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_next</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">family</span> <span class="o">=</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_addr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">required_family</span> <span class="o">&amp;&amp;</span> <span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">getnameinfo</span><span class="p">(</span><span class="n">ifa</span><span class="o">-&gt;</span><span class="n">ifa_addr</span><span class="p">,</span>
    <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">)</span> <span class="o">:</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span><span class="p">),</span>
    <span class="n">host</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="n">port</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">NI_NUMERICHOST</span> <span class="o">|</span> <span class="n">NI_NUMERICSERV</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To get your IP Address from the command line use <code class="language-plaintext highlighter-rouge">ifconfig</code> or Windows’
<code class="language-plaintext highlighter-rouge">ipconfig</code>.</p>
<p>However, this command generates a lot of output for each interface, so
we can filter the output using grep.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifconfig | grep inet

Example output:
    inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1
    inet 127.0.0.1 netmask 0xff000000
    inet6 ::1 prefixlen 128
    inet6 fe80::7256:81ff:fe9a:9141%en1 prefixlen 64 scopeid 0x5
    inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
</code></pre></div></div>
<p>To grab the IP Address of a remote website, The function <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code>
can convert a human-readable domain name (e.g. <code class="language-plaintext highlighter-rouge">www.illinois.edu</code>) into
an IPv4 and IPv6 address. It will return a linked-list of addrinfo
structs:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="p">{</span>
  <span class="kt">int</span>              <span class="n">ai_flags</span><span class="p">;</span>
  <span class="kt">int</span>              <span class="n">ai_family</span><span class="p">;</span>
  <span class="kt">int</span>              <span class="n">ai_socktype</span><span class="p">;</span>
  <span class="kt">int</span>              <span class="n">ai_protocol</span><span class="p">;</span>
  <span class="n">socklen_t</span>        <span class="n">ai_addrlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">ai_addr</span><span class="p">;</span>
  <span class="kt">char</span>            <span class="o">*</span><span class="n">ai_canonname</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">ai_next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>For example, suppose you wanted to find out the numeric IPv4 address of
a web server at <code class="language-plaintext highlighter-rouge">www.bbc.com</code>. We do this in two stages. First, use
getaddrinfo to build a linked-list of possible connections. Secondly,
use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getnameinfo.3p.html" class="fancy-link">getnameinfo</a></code> to convert the binary address of one of those into a
readable form.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">infoptr</span><span class="p">;</span> <span class="c1">// So no need to use memset global variables</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span> <span class="c1">// AF_INET means IPv4 only addresses</span>

  <span class="c1">// Get the machine addresses</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="s">"www.bbc.com"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">infoptr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"getaddrinfo: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">host</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

  <span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">infoptr</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Get the name for all returned addresses</span>
    <span class="n">getnameinfo</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NI_NUMERICHOST</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">infoptr</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Possible output.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>212.58.244.70
212.58.244.71
</code></pre></div></div>
<p>One can specify IPv4 or IPv6 with <code class="language-plaintext highlighter-rouge">AF_UNSPEC</code>. Just replace the
ai_family attribute in the above code with the following.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hints.ai_family = AF_UNSPEC
</code></pre></div></div>
<p>If you are wondering how the computer maps hostnames to addresses, we
will talk about that in Layer 7. Spoiler: It is a service called DNS.
Before we move onto the next section, it is important to note that a
single website can have multiple IP addresses. This may be to be
efficient with machines. If Google or Facebook has a single server
routing <em>all</em> of their incoming requests to other computers, they’d have
to spend massive amounts of money on that computer or data center.
Instead, they can give different regions different IP addresses and have
a computer pick. It isn’t bad to access a website through the
non-preferred IP address. The page may load slower.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="layer-4-tcp-and-client" class="title-text">Layer 4: TCP and Client<a class="anchor title-text" href="#layer-4-tcp-and-client"> #</a>
</h2></div>









































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/networking/drawings/tcp_header.png" alt="Extra: TCP Header
Specification"></p>
<p>Most services on the Internet today use TCP because it efficiently hides
the complexity of the lower, packet-level nature of the Internet. TCP or
Transport Control Protocol is a connection-based protocol that is built
on top of IPv4 and IPv6 and therefore can be described as “TCP/IP” or
“TCP over IP”. TCP creates a <em>pipe</em> between two machines and abstracts
away the low-level packet-nature of the Internet. Thus, under most
conditions, bytes sent over a TCP connection delivered and uncorrupted.
High performance and error-prone code won’t even assume that!</p>
<p>TCP has many features that set it apart from the other transport
protocol UDP.</p>
<ol>
  <li>
    <p>Ports With IP, you are only allowed to send packets to a machine. If
you want one machine to handle multiple flows of data, you have to
do it manually with IP. TCP gives the programmer a set of virtual
sockets. Clients specify the socket that you want the packet sent to
and the TCP protocol makes sure that applications that are waiting
for packets on that port receive that. A process can listen for
incoming packets on a particular port. However, only processes with
super-user (root) access can listen on ports less than 1024. Any
process can listen on ports 1024 or higher. A frequently used port
is number 80. It is used for unencrypted HTTP requests or web pages.
For example, if a web browser connects to <code class="language-plaintext highlighter-rouge">http://www.bbc.com/</code> then
it will be connecting to port 80.</p>
  </li>
  <li>
    <p>Retransmission Packets can get dropped due to network errors or
congestion. As such, they need to be retransmitted. At the same
time, the retransmission shouldn’t cause packets more packets to be
dropped. This needs to balance the tradeoff between flooding the
network and speed.</p>
  </li>
  <li>
    <p>Out of order packets. Packets may get routed more favorably due to
various reasons in IP. If a later packet arrives before another
packet, the protocol should detect and reorder them.</p>
  </li>
  <li>
    <p>Duplicate packets. Packets can arrive twice. Packets can arrive
twice. As such, a protocol needs to be able to differentiate between
two packets given a sequence number subject to overflow.</p>
  </li>
  <li>
    <p>Error correction. There is a TCP checksum that handles bit errors.
This is rarely used though.</p>
  </li>
  <li>
    <p>Flow Control. Flow control is performed on the receiver side. This
may be done so that a slow receiver doesn’t get overwhelmed with
packets. Servers that handle 10000 or 10 million concurrent
connections may need to tell receivers to slow down but remain
connected due to load. There is also the problem of making sure the
local network’s traffic is stable.</p>
  </li>
  <li>
    <p>Congestion control. Congestion control is performed on the sender’s
side. Congestion control is to avoid a sender from flooding the
network with too many packets. This is important to make sure that
each TCP connection is treated fairly. Meaning that two connections
leaving a computer to google and youtube receive the same bandwidth
and ping as each other. One can easily define a protocol that takes
all the bandwidth and leaves other protocols in the dust, but this
tends to be malicious because many times limiting a computer to a
single TCP connection will yield the same result.</p>
  </li>
  <li>
    <p>Connection-Oriented/life cycle oriented. You can imagine a TCP
connection as a series of bytes sent through a pipe. There is a
“lifecycle” to a TCP connection though. TCP handles setting up the
connection through SYN SYN-ACK ACK. This means the client will send
a SYNchronization packet that tells TCP what starting sequence to
start on. Then the receiver will send a SYN-ACK message
acknowledging the synchronization number. Then the client will
ACKnowledge that with one last packet. The connection is now open
for both reading and writing on both ends TCP will send data and the
receiver of the data will acknowledge that it received a packet.
Then every so often if a packet is not sent, TCP will trade
zero-length packets to make sure the connection is still alive. At
any point, the client and server can send a FIN packet meaning that
the server will not transmit. This packet can be altered with bits
that only close the read or write end of a particular connection.
When all ends are closed then the connection is over.</p>
  </li>
</ol>
<p>TCP doesn’t provide many things, though.</p>
<ol>
  <li>
    <p>Security. Connecting to an IP address claiming to be a certain
website does not verify the claim (like in TLS). You could be
sending packets to a malicious computer.</p>
  </li>
  <li>
    <p>Encryption. Anybody can listen in on plain TCP. The packets in
transport are in plain text. Important things like your passwords
could easily be skimmed by onlookers.</p>
  </li>
  <li>
    <p>Session Reconnection. If a TCP connection dies then a whole new one
must be created, and the transmission has to be started over again.
This is handled by a higher protocol.</p>
  </li>
  <li>
    <p>Delimiting Requests. TCP is naturally connection-oriented.
Applications that are communicating over TCP need to find a unique
way of telling each other that this request or response is over.
HTTP delimits the header through two carriage returns and uses
either a length field or one keeps listening until the connection
closes</p>
  </li>
</ol>
<h3 id="note-on-network-orders" class="title-text">Note on network orders</h3>
<p>Integers can be represented in the least significant byte first or most
significant byte first. Either approach is reasonable as long as the
machine itself is internally consistent. For network communications, we
need to standardize on the agreed format.</p>
<p><code class="language-plaintext highlighter-rouge">htons(xyz)</code> returns the 16-bit unsigned integer ‘short’ value xyz in
network byte order. <code class="language-plaintext highlighter-rouge">htonl(xyz)</code> returns the 32-bit unsigned integer
‘long’ value xyz in network byte order. Any longer integers need to
have the computers specify the order.</p>
<p>These functions are read as ‘host to network’. The inverse functions
(<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/ntohs.3p.html" class="fancy-link">ntohs</a></code>, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/ntohl.3p.html" class="fancy-link">ntohl</a></code>) convert network ordered byte values to host-ordered
ordering. So, is host-ordering little-endian or big-endian? The answer
is - it depends on your machine! It depends on the actual architecture
of the host running the code. If the architecture happens to be the same
as network ordering then the functions return identical integers. For
x86 machines, the host and network order are different.</p>
<p>Unless agreed otherwise, whenever you read or write the low-level C
network structures, i.e. port and address information, remember to use
the above functions to ensure correct conversion to/from a machine
format. Otherwise, the displayed or specified value may be incorrect.</p>
<p>This doesn’t apply to protocols that negotiate the endianness
before-hand. If two computers are CPU bound by converting the messages
between network orders – this happens with RPCs in high-performance
systems – it may be worth it to negotiate if they are on similar
endianness to send in little-endian order.</p>
<p>Why is network order defined to be big-endian? The simple answer is that
RFC1700 says so (Reynolds and Postel
<a href="#ref-RFC1700" class="fancy-link wiki-link">#ref-RFC1700</a>). If you want more information,
we’ll cite the famous article located that argued for a particular
version (Cohen <a href="#ref-cohen_1980" class="fancy-link wiki-link">#ref-cohen_1980</a>). The most
important part is that it is standard. What happens when we don’t have
one standard? We have 4 different USB plug types (Regular, Micro, Mini,
and USB-C) that don’t interact well with each other. Include relevant
XKCD here <a href="https://xkcd.com/927/" class="fancy-link wiki-link">https://xkcd.com/927/</a>.</p>
<h3 id="tcp-client" class="title-text">TCP Client</h3>
<p>There are three basic system calls to connect to a remote machine.</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int getaddrinfo(const char *node, const char *service, const struct
addrinfo *hints, struct addrinfo **res);</code></p>

    <p>The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> call if successful, creates a linked-list of
<code class="language-plaintext highlighter-rouge">addrinfo</code> structs and sets the given pointer to point to the first
one.</p>

    <p>Also, you can use the hints struct to only grab certain entries like
certain IP protocols, etc. The addrinfo structure that is passed
into <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> to define the kind of connection you’d like. For
example, to specify stream-based protocols over IPv6, you can use
the following snippet.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hints</span><span class="p">));</span>
    
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span> <span class="c1">// Only want IPv6 (use AF_INET for IPv4)</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="c1">// Only want stream-based connection</span>
</code></pre></div>    </div>

    <p>The other modes for ‘family‘ are <code class="language-plaintext highlighter-rouge">AF_INET4</code> and <code class="language-plaintext highlighter-rouge">AF_UNSPEC</code> which
mean IPv4 and unspecified respectively. This could be useful if you
are searching for a service that you aren’t entirely sure which IP
version. Naturally, you get the version in the field back if you
specified UNSPEC.</p>

    <p>Error handling with <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> is a little different. The return
value <em>is</em> the error code. To convert to a human-readable error use
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/gai_strerror.3p.html" class="fancy-link">gai_strerror</a></code> to get the equivalent short English error text.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(...);</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span> <span class="o">=</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int socket(int domain, int socket_type, int protocol);</code></p>

    <p>The socket call creates a network socket and returns a descriptor
that can be used with <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>. In this sense, it is the
network analog of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/open.3p.html" class="fancy-link">open</a></code> that opens a file stream – except that we
haven’t connected the socket to anything yet!</p>

    <p>Sockets are created with a domain <code class="language-plaintext highlighter-rouge">AF_INET</code> for <code class="language-plaintext highlighter-rouge">IPv4</code> or <code class="language-plaintext highlighter-rouge">AF_INET6</code>
for <code class="language-plaintext highlighter-rouge">IPv6</code>, <code class="language-plaintext highlighter-rouge">socket_type</code> is whether to use UDP, TCP, or other some
other socket type, the <code class="language-plaintext highlighter-rouge">protocol</code> is an optional choice of protocol
configuration for our examples this we can leave this as 0 for
default. This call creates a socket object in the kernel with which
one can communicate with the outside world/network. You can use the
result of <code class="language-plaintext highlighter-rouge">getaddressinfo</code> to fill in the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/socket.3p.html" class="fancy-link">socket</a></code> parameters, or
provide them manually.</p>

    <p>The socket call returns an integer - a file descriptor - and, for
TCP clients, you can use it as a regular file descriptor. You can
use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code> to receive or send packets.</p>

    <p>TCP sockets are similar to <code class="language-plaintext highlighter-rouge">pipes</code> and are often used in situations
that require IPC. We don’t mention it in the previous chapters
because it is overkill using a device suited for networks to simply
communicate between processes on a single thread.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">connect(int sockfd, const struct sockaddr *addr, socklen_t
addrlen);</code></p>

    <p>Finally, the connect call attempts the connection to the remote
machine. We pass the original socket descriptor and also the socket
address information which is stored inside the addrinfo structure.
There are different kinds of socket address structures that can
require more memory. So in addition to passing the pointer, the size
of the structure is also passed. To help identify errors and
mistakes it is good practice to check the return value of all
networking calls, including <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/connect.3p.html" class="fancy-link">connect</a></code></p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">// Pull out the socket address info from the addrinfo struct:</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(Optional) To clean up code call <code class="language-plaintext highlighter-rouge">freeaddrinfo(struct addrinfo *ai)</code>
on the first level <code class="language-plaintext highlighter-rouge">addrinfo</code> struct.</p>
  </li>
</ol>
<p>There is an old function <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/gethostbyname.3.html" class="fancy-link">gethostbyname</a></code> is deprecated. It’s the old way
convert a hostname into an IP address. The port address still needs to
be manually set using <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/htons.3p.html" class="fancy-link">htons</a></code> function. It’s much easier to write code
to support IPv4 AND IPv6 using the newer <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code></p>
<p>This is all that is needed to create a <em>simple</em> TCP client. However,
network communications offer many different levels of abstraction and
several attributes and options that can be set at each level. For
example, we haven’t talked about <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/setsockopt.3p.html" class="fancy-link">setsockopt</a></code> which can manipulate
options for the socket. You can also mess around with lower protocols as
the kernel provides primitives that contribute to this. Note that you
need to be root to create a raw socket. Also, you need to have a lot of
“set up” or starter code, be prepared to have your datagrams be
dropped due to bad form as well. For more information see this
<a href="http://www.beej.us/guide/bgnet/output/html/multipage/getaddrinfoman.html" class="fancy-link wiki-link">http://www.beej.us/guide/bgnet/output/html/multipage/getaddrinfoman.html</a>.</p>
<h3 id="sending-some-data" class="title-text">Sending some data</h3>
<p>Once we have a successful connection we can read or write like any old
file descriptor. Keep in mind if you are connected to a website, you
want to conform to the HTTP protocol specification to get any sort of
meaningful results back. There are libraries to do this. Usually, you
don’t connect at the socket level. The number of bytes read or written
may be smaller than expected. Thus, it is important to check the return
value of and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>. A simple HTTP client that sends a request to a
compliant URL is below. First, we’ll start with the boring stuff and the
parsing code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_host_info</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">resource</span><span class="p">;</span>
<span class="p">}</span> <span class="n">host_info</span><span class="p">;</span>

<span class="n">host_info</span> <span class="o">*</span><span class="nf">get_info</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... Parses the URI/URL</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_info</span><span class="p">(</span><span class="n">host_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... Frees any info</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s http://hostname[:port]/path</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">argv</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">host_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">get_info</span><span class="p">(</span><span class="n">uri</span><span class="p">);</span>
  <span class="n">host_info</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">send_request</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The code that sends the request is below. The first thing that we have
to do is connect to an address.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">current</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
<span class="n">current</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">current</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>

<span class="n">getaddrinfo</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>

<span class="n">connect</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span>

<span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre></div></div>
<p>The next piece of code sends the request. Here is what each header
means.</p>
<ol>
  <li>
    <p>“GET %s HTTP/1.0” This is the request verb interpolated with the
path. This means to perform the GET verb on the path using the
HTTP/1.0 method.</p>
  </li>
  <li>
    <p>“Connection: close” Means that as soon as the request is over,
please close the connection. This line won’t be used for any other
connections. This is a little redundant given that HTTP 1.0 doesn’t
allow you to send multiple requests, but it is better to be explicit
given there are non-conformant technologies.</p>
  </li>
  <li>
    <p>“Accept: */*” This means that the client is willing to accept
anything.</p>
  </li>
</ol>
<p>A more robust piece of code would also check if the write fails or if
the call was interrupted.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
  <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span>
  <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span>
  <span class="s">"Accept: */*</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span>
  <span class="n">info</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">);</span>

<span class="n">write</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
<span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>
<p>The last piece of code is the driver code that sends the request. Feel
free to use the following code if you want to open the file descriptor
as a FILE object for convenience functions. Just be careful not to
forget to set the buffering to zero otherwise you may double buffer the
input, which would lead to performance problems.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">send_request</span><span class="p">(</span><span class="n">host_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sock_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// Re-use address is a little overkill here because we are making a</span>
  <span class="c1">// Listen only server and we don't expect spoofed requests.</span>
  <span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">setsockopt</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">optval</span><span class="p">));</span>
  <span class="k">if</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"setsockopt"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Connect using code snippet</span>

  <span class="c1">// Send the get request</span>

  <span class="c1">// Open so you can use getline</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">sock_file</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="s">"r+"</span><span class="p">);</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">sock_file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="n">handle_okay</span><span class="p">(</span><span class="n">sock_file</span><span class="p">);</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">sock_file</span><span class="p">);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The example above demonstrates a request to the server using the
HyperText Transfer Protocol. In general, there are six parts</p>
<ol>
  <li>
    <p>The method. GET, POST, etc.</p>
  </li>
  <li>
    <p>The resource. “/” “/index.html” “/image.png”</p>
  </li>
  <li>
    <p>The protocol “HTTP/1.0”</p>
  </li>
  <li>
    <p>A new line (<code class="language-plaintext highlighter-rouge">  r n </code>). Requests always have a carriage return.</p>
  </li>
  <li>
    <p>Any other knobs or switch parameters</p>
  </li>
  <li>
    <p>The actual body of the request delimited by two new lines. The body
of the request is either if the size is specified or until the
receiver closes their connection.</p>
  </li>
</ol>
<p>The server’s first response line describes the HTTP version used and
whether the request is successful using a 3 digit response code.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
</code></pre></div></div>
<p>If the client had requested a non-existent path, e.g. <code class="language-plaintext highlighter-rouge">GET
/nosuchfile.html HTTP/1.0</code> Then the first line includes the response
code is the well-known <code class="language-plaintext highlighter-rouge">404</code> response code.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 404 Not Found
</code></pre></div></div>
<p>For more information, RFC 7231 has the most current specifications on
the most common HTTP method today (Fielding and Reschke
<a href="#ref-rfc7231" class="fancy-link wiki-link">#ref-rfc7231</a>).</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="layer-4-tcp-server" class="title-text">Layer 4: TCP Server<a class="anchor title-text" href="#layer-4-tcp-server"> #</a>
</h2></div>







































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The four system calls required to create a minimal TCP server are
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/socket.3p.html" class="fancy-link">socket</a></code>, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/bind.3p.html" class="fancy-link">bind</a></code>, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/listen.3p.html" class="fancy-link">listen</a></code>, and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/accept.3p.html" class="fancy-link">accept</a></code>. Each has a specific purpose
and should be called in roughly the above order</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int socket(int domain, int socket_type, int protocol)</code></p>

    <p>To create an endpoint for networking communication. A new socket by
itself is stores bytes. Though we’ve specified either a packet or
stream-based connections, it is unbound to a particular network
interface or port. Instead, socket returns a network descriptor that
can be used with later calls to bind, listen and accept.</p>

    <p>As one gotcha, these sockets must be declared passive. Passive
server sockets wait for another host to connect. Instead, they wait
for incoming connections. Additionally, server sockets remain open
when the peer disconnects. Instead, the client communicates with a
separate active socket on the server that is specific to that
connection.</p>

    <p>Since a TCP connection is defined by the sender address and port
along with a receiver address and port, a particular server port
there can be one passive server socket but multiple active sockets.
One for each currently open connection. The server’s operating
system maintains a lookup table that associates a unique tuple with
active sockets so that incoming packets can be correctly routed to
the correct socket.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int bind(int sockfd, const struct sockaddr *addr, socklen_t
addrlen);</code></p>

    <p>The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/bind.3p.html" class="fancy-link">bind</a></code> call associates an abstract socket with an actual network
interface and port. It is possible to call bind on a TCP client. The
port information used by bind can be set manually (many older
IPv4-only C code examples do this), or be created using
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code>.</p>

    <p>By default, a port is released after some time when the server
socket is closed. Instead, the port enters a “TIMED-WAIT” state.
This can lead to significant confusion during development because
the timeout can make valid networking code appear to fail.</p>

    <p>To be able to immediately reuse a port, specify <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code>
before binding to the port.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">optval</span><span class="p">));</span>
    
<span class="n">bind</span><span class="p">(...);</span>
</code></pre></div>    </div>

    <p>Here’s
<a href="http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t" class="fancy-link wiki-link">http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t</a>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int listen(int sockfd, int backlog);</code></p>

    <p>The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/listen.3p.html" class="fancy-link">listen</a></code> call specifies the queue size for the number of
incoming, unhandled connections. There are the connections
unassigned to a file descriptor by <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/accept.3p.html" class="fancy-link">accept</a></code>. Typical values for a
high-performance server are 128 or more.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p>

    <p>Once the server socket has been initialized the server calls
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/accept.3p.html" class="fancy-link">accept</a></code> to wait for new connections. Unlike <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/socket.3p.html" class="fancy-link">socket</a></code> <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/bind.3p.html" class="fancy-link">bind</a></code> and
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/listen.3p.html" class="fancy-link">listen</a></code>, this call will block, unless the nonblocking option has
been set. If there are no new connections, this call will block and
only return when a new client connects. The returned TCP socket is
associated with a particular tuple <code class="language-plaintext highlighter-rouge">(client IP, client port, server
IP, server port)</code> and will be used for all future incoming and
outgoing TCP packets that match this tuple.</p>

    <p>Note the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/accept.3p.html" class="fancy-link">accept</a></code> call returns a new file descriptor. This file
descriptor is specific to a particular client. It is a common
programming mistake to use the original server socket descriptor for
the server I/O and then wonder why networking code has failed.</p>

    <p>The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/accept.3p.html" class="fancy-link">accept</a></code> system call can optionally provide information about
the remote client, by passing in a sockaddr struct. Different
protocols have different variants of the <code class="language-plaintext highlighter-rouge">struct sockaddr</code>, which
are different sizes. The simplest struct to use is the
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sockaddr_storage.3type.html" class="fancy-link">sockaddr_storage</a></code> which is sufficiently large to represent all
possible types of sockaddr. Notice that C does not have any model of
inheritance. Therefore we need to explicitly cast our struct to the
‘base type’ struct sockaddr.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>
<span class="n">socklen_t</span> <span class="n">clientaddrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">client_id</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">passive_socket</span><span class="p">,</span>
  <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">clientaddrsize</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>We’ve already seen <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> that can build a linked list of
addrinfo entries and each one of these can include socket
configuration data. What if we wanted to turn socket data into IP
and port addresses? Enter <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getnameinfo.3p.html" class="fancy-link">getnameinfo</a></code> that can be used to convert
local or remote socket information into a domain name or numeric IP.
Similarly, the port number can be represented as a service name. For
example, port 80 is commonly used as the incoming connection port
for incoming HTTP requests. In the example below, we request numeric
versions for the client IP address and client port number.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="n">socklen_t</span> <span class="n">clientaddrsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
 <span class="kt">int</span> <span class="n">client_id</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock_id</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientaddrsize</span><span class="p">);</span>
 <span class="kt">char</span> <span class="n">host</span><span class="p">[</span><span class="n">NI_MAXHOST</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="n">NI_MAXSERV</span><span class="p">];</span>
 <span class="n">getnameinfo</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span>
  <span class="n">clientaddrsize</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="n">port</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">port</span><span class="p">),</span>
  <span class="n">NI_NUMERICHOST</span> <span class="o">|</span> <span class="n">NI_NUMERICSERV</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>One can use the macros <code class="language-plaintext highlighter-rouge">NI_MAXHOST</code> to denote the maximum length of
a hostname, and <code class="language-plaintext highlighter-rouge">NI_MAXSERV</code> to denote the maximum length of a port.
<code class="language-plaintext highlighter-rouge">NI_NUMERICHOST</code> gets the hostname as a numeric IP address and
similarly for <code class="language-plaintext highlighter-rouge">NI_NUMERICSERV</code> although the port is usually numeric,
to begin with. The
<a href="https://man.openbsd.org/getnameinfo.3#NI_NUMERICHOST" class="fancy-link wiki-link">https://man.openbsd.org/getnameinfo.3#NI_NUMERICHOST</a></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int close(int fd)</code> and <code class="language-plaintext highlighter-rouge">int shutdown(int fd, int how)</code></p>

    <p>Use the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/shutdown.3p.html" class="fancy-link">shutdown</a></code> call when you no longer need to read any more
data from the socket, write more data, or have finished doing both.
When you call <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/shutdown.3p.html" class="fancy-link">shutdown</a></code> on socket on the read and/or write ends,
that information is also sent to the other end of the connection. If
you shut down the socket for further writing at the server end, then
a moment later, a blocked <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> call could return 0 to indicate
that no more bytes are expected. Similarly, a write to a TCP
connection that has been shut down for reading will generate a
SIGPIPE</p>

    <p>Use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/close.3p.html" class="fancy-link">close</a></code> when your process no longer needs the socket file
descriptor.</p>

    <p>If you <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fork.3p.html" class="fancy-link">fork</a></code>-ed after creating a socket file descriptor, all
processes need to close the socket before the socket resources can
be reused. If you shut down a socket for further read, all processes
are affected because you’ve changed the socket, not the file
descriptor. Well written code will <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/shutdown.3p.html" class="fancy-link">shutdown</a></code> a socket before
calling <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/close.3p.html" class="fancy-link">close</a></code> it.</p>
  </li>
</ol>
<p>There are a few gotchas to creating a server.</p>
<ul>
  <li>
    <p>Using the socket descriptor of the passive server socket (described
above)</p>
  </li>
  <li>
    <p>Not specifying SOCK_STREAM requirement for getaddrinfo</p>
  </li>
  <li>
    <p>Not being able to reuse an existing port.</p>
  </li>
  <li>
    <p>Not initializing the unused struct entries</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/bind.3p.html" class="fancy-link">bind</a></code> call will fail if the port is currently in use. Ports are
per machine – not per process or user. In other words, you cannot
use port 1234 while another process is using that port. Worse, ports
are by default ‘tied up’ after a process has finished.</p>
  </li>
</ul>
<h3 id="example-server" class="title-text">Example Server</h3>
<p>A working simple server example is shown below. Note: this example is
incomplete. For example, the socket file descriptor remains open and
memory created by <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> remains allocated. First, we get the
address info for our current machine.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"getaddrinfo: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">gai_strerror</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Then we set up the socket, bind it, and listen.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sock_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Bind and listen</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"bind()"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"listen()"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We are finally ready to listen for connections, so we’ll tell the user
and accept our first
client.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">result_addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Listening on file descriptor %d, port %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sock_fd</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">result_addr</span><span class="o">-&gt;</span><span class="n">sin_port</span><span class="p">));</span>

<span class="c1">// Waiting for connections like a passive socket</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Waiting for connection...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Connection made: client_fd=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">client_fd</span><span class="p">);</span>
</code></pre></div></div>
<p>After that, we can treat the new file descriptor as a stream of bytes
much like a pipe.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
<span class="c1">// Could get interrupted</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">buffer</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"Read %d chars</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"===</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div>
<p>[language=C]</p>
<h3 id="sorry-to-interrupt" class="title-text">Sorry To Interrupt</h3>
<p>One concept that we need to make clear is that you need to handle
interrupts in your networking code. That means that the sockets or
accepted file descriptors that you read to or write to may have their
calls interrupted – most of the time you will get an interrupt or two.
In reality, any of your system calls could get interrupted. The reason
we bring this up now is that you are usually waiting for the network.
Which is an order of magnitude slower than processes. Meaning a higher
probability of getting interrupted.</p>
<p>How would you handle interrupts? Let’s try a quick example.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">bytes_read</span> <span class="n">isn</span><span class="err">'</span><span class="n">t</span> <span class="n">count</span> <span class="p">{</span>
  <span class="n">bytes_read</span> <span class="o">+=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">error</span> <span class="n">is</span> <span class="n">EINTR</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We can assure you that the following code <em>experience errors</em>. Can you
see why? On the surface, it does restart a call after a read or write.
But what else happens when the error is EINTR? Are the contents of the
buffer correct? What other problems can you spot?</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="layer-4-udp" class="title-text">Layer 4: UDP<a class="anchor title-text" href="#layer-4-udp"> #</a>
</h2></div>



























































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>UDP is a connectionless protocol that is built on top of IPv4 and IPv6.
It’s simple to use. Decide the destination address and port and send
your data packet! However, the network makes no guarantee about whether
the packets will arrive. Packets may be dropped if the network is
congested. Packets may be duplicated or arrive out of order.</p>
<p>A typical use case for UDP is when receiving up to date data is more
important than receiving all of the data. For example, a game may send
continuous updates of player positions. A streaming video signal may
send picture updates using UDP</p>
<h3 id="udp-attributes" class="title-text">UDP Attributes</h3>
<ul>
  <li>
    <p>Unreliable Datagram Protocol Packets sent through UDP may be dropped
on their way to the destination. This can especially be confusing
because if you only test on your loop-back device – this is
localhost or 127.0.0.1 for most users – then packets will seldom be
lost because no network packets are sent.</p>
  </li>
  <li>
    <p>Simple The UDP protocol is supposed to have much less fluff than
TCP. Meaning that for TCP there are a lot of configurable parameters
and a lot of edge cases in the implementation. UDP is fire and
forget.</p>
  </li>
  <li>
    <p>Stateless/Transaction The UDP protocol is stateless. This makes the
protocol more simple and lets the protocol represent simple
transactions like requesting or responding to queries. There is also
less overhead to sending a UDP message because there is no three-way
handshake.</p>
  </li>
  <li>
    <p>Manual Flow/Congestion Control You have to manually manage the flow
and congestion control which is a double-edged sword. On one hand,
you have full control over everything. On the other hand, TCP has
<em>decades</em> of optimization, meaning your protocol for its use cases
needs to be more efficient that to be more beneficial to use it.</p>
  </li>
  <li>
    <p>Multicast This is one thing that you can only do with UDP. This
means that you can send a message to every peer connected to a
particular router that is part of a particular group.</p>
  </li>
</ul>
<p>The full gory description is available at the original RFC (“User
Datagram Protocol” <a href="#ref-rfc768" class="fancy-link wiki-link">#ref-rfc768</a>).</p>
<p>While it may seem that you never want to use UDP for situations that you
don’t want to lose data, a lot of protocols base their communication
based on UDP that requires complete data. Take a look at the Trivial
File Transfer Protocol that reliably transmits a file over the wire
using UDP only. Of course, there is more configuration involved, but
choosing between UDP over TCP involves more than the above factors.</p>
<h3 id="udp-client" class="title-text">UDP Client</h3>
<p>UDP Clients are pretty versatile below is a simple client that sends a
packet to a server specified through the command line. Note that this
client sends a packet and doesn’t wait for an acknowledgment. It fires
and forgets. The example below also uses <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/gethostbyname.3.html" class="fancy-link">gethostbyname</a></code> because some
legacy functionality still works pretty well for setting up a client.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
<span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">port</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">hostent</span> <span class="o">*</span><span class="n">serv</span> <span class="o">=</span> <span class="n">gethostbyname</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>
</code></pre></div></div>
<p>The previous code grabs an entry <code class="language-plaintext highlighter-rouge">hostent</code> that matches by hostname.
Even though this isn’t portable, it gets the job done. First is to
connect to it and make it reusable – the same as a TCP socket. Note that
we pass <code class="language-plaintext highlighter-rouge">SOCK_DGRAM</code> instead of <code class="language-plaintext highlighter-rouge">SOCK_STREAM</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">optval</span><span class="p">));</span>
</code></pre></div></div>
<p>Then, we can copy over our <code class="language-plaintext highlighter-rouge">hostent</code> struct into the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sockaddr_in.3type.html" class="fancy-link">sockaddr_in</a></code>
struct. Full definitions are provided in the man pages so it is safe to
copy them over.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">h_addr</span><span class="p">,</span> <span class="n">serv</span><span class="o">-&gt;</span><span class="n">h_length</span><span class="p">);</span>
</code></pre></div></div>
<p>Then a final useful part of UDP is that we can time out receiving a
packet as opposed to TCP because UDP isn’t connection-oriented. The
snippet to do that is below.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
<span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">SOCKET_TIMEOUT</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_RCVTIMEO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">));</span>
</code></pre></div></div>
<p>Now, the socket is connected and ready to use. We can use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sendto.3p.html" class="fancy-link">sendto</a></code> to
send a packet. We should also check the return value. Note that we won’t
get an error if the packet isn’t delivered because that is a part of the
UDP protocol. We will, however, get error codes for invalid structs, bad
addresses, etc.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">to_send</span> <span class="o">=</span> <span class="s">"Hello!"</span>
<span class="kt">int</span> <span class="n">send_ret</span> <span class="o">=</span> <span class="n">sendto</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="c1">// Socket</span>
   <span class="n">to_send</span><span class="p">,</span> <span class="c1">// Data</span>
   <span class="n">strlen</span><span class="p">(</span><span class="n">to_send</span><span class="p">),</span> <span class="c1">// Length of data</span>
   <span class="mi">0</span><span class="p">,</span> <span class="c1">// Flags</span>
   <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ipaddr</span><span class="p">,</span> <span class="c1">// Address</span>
   <span class="k">sizeof</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">));</span> <span class="c1">// How long the address is</span>
</code></pre></div></div>
<p>The above code simply sends “Hello” through a UDP. There is no idea of
if the packet arrives, is processed, etc.</p>
<h3 id="udp-server" class="title-text">UDP Server</h3>
<p>There are a variety of function calls available to send UDP sockets. We
will use the newer <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/getaddrinfo.3p.html" class="fancy-link">getaddrinfo</a></code> to help set up a socket structure.
Remember that UDP is a simple packet-based (‘datagram’) protocol. There
is no connection to set up between the two hosts. First, initialize the
hints addrinfo struct to request an IPv6, passive datagram socket.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hints</span><span class="p">));</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span>  <span class="n">SOCK_DGRAM</span><span class="p">;</span>
<span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span>  <span class="n">AI_PASSIVE</span><span class="p">;</span>
</code></pre></div></div>
<p>Next, use getaddrinfo to specify the port number. We don’t need to
specify a host as we are creating a server socket, not sending a packet
to a remote host. Be careful not to send “localhost” or any other
synonym for the loop-back address. We may end up trying to passively
listen to ourselves and resulting in bind errors.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"300"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

<span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>
<span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);</span>
</code></pre></div></div>
<p>The port number is less than 1024, so the program will need <code class="language-plaintext highlighter-rouge">root</code>
privileges. We could have also specified a service name instead of a
numeric port value.</p>
<p>So far, the calls have been similar to a TCP server. For a stream-based
service, we would call <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/listen.3p.html" class="fancy-link">listen</a></code> and accept. For our UDP-server, the
program can start waiting for the arrival of a packet.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">addr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="c1">// ssize_t recvfrom(int socket, void* buffer, size_t buflen, int flags, struct sockaddr *addr, socklen_t * address_len);</span>

<span class="n">byte_count</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div></div>
<p>The addr struct will hold the sender (source) information about the
arriving packet. Note the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sockaddr_storage.3type.html" class="fancy-link">sockaddr_storage</a></code> type is sufficiently large
enough to hold all possible types of socket addresses – IPv4, IPv6 or
any other Internet Protocol. The full UDP server code is below.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hints</span><span class="p">));</span>
  <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span> <span class="c1">// INET for IPv4</span>
  <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span>  <span class="n">SOCK_DGRAM</span><span class="p">;</span>
  <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span>  <span class="n">AI_PASSIVE</span><span class="p">;</span>

  <span class="n">getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"300"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"bind()"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">ssize_t</span> <span class="n">byte_count</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
    <span class="n">buf</span><span class="p">[</span><span class="n">byte_count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Read %d chars</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">byte_count</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"===</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note that if you perform a partial read from a packet, the rest of that
data is discarded. One call to recvfrom is one packet. To make sure that
you have enough space, use 64 KiB as storage space.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="layer-7-http" class="title-text">Layer 7: HTTP<a class="anchor title-text" href="#layer-7-http"> #</a>
</h2></div>

















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Layer 7 of the OSI layer deals with application-level interfaces.
Meaning that you can ignore everything below this layer and treat the
Internet as a way of communicating with another computer than can be
secure and the session may reconnect. Common layer 7 protocols are the
following</p>
<ol>
  <li>
    <p>HTTP(S) - Hypertext Transfer Protocol. Sends arbitrary data and
executes remote actions on a web server. The S standards for secure
where the TCP connection uses the TLS protocol to ensure that the
communication can’t be read easily by an onlooker.</p>
  </li>
  <li>
    <p>FTP - File Transfer Protocol. Transfers a file from one computer to
another</p>
  </li>
  <li>
    <p>TFTP - Trivial File Transfer Protocol. Same as above but using UDP.</p>
  </li>
  <li>
    <p>DNS - Domain Name Service. Translates hostnames to IP addresses</p>
  </li>
  <li>
    <p>SMTP - Simple Mail Transfer Protocol. Allows one to send plain text
emails to an email server</p>
  </li>
  <li>
    <p>SSH - Secure SHell. Allows one computer to connect to another
computer and execute commands remotely.</p>
  </li>
  <li>
    <p>Bitcoin - Decentralized cryptocurrency</p>
  </li>
  <li>
    <p>BitTorrent - Peer to peer file sharing protocol</p>
  </li>
  <li>
    <p>NTP - Network Time Protocol. This protocol helps keep your
computer’s clock synced with the outside world</p>
  </li>
</ol>
<h3 id="whats-my-name" class="title-text">What’s my name?</h3>
<p>Remember when we were talking before about converting a website to an IP
address? A system called “DNS” (Domain Name Service) is used. If the IP
address is missing form a machine’s cache then it sends a UDP packet to
a local DNS server. This server may query other upstream DNS servers.</p>
<p>DNS by itself is fast but insecure. DNS requests are unencrypted and
susceptible to ‘man-in-the-middle’ attacks. For example, a coffee shop
internet connection could easily subvert your DNS requests and send back
different IP addresses for a particular domain. The way this is usually
subverted is that after the IP address is obtained then a connection is
usually made over HTTPS. HTTPS uses what is called the TLS (formerly
known as SSL) to secure transmissions and verify that the hostname is
recognized by a Certificate Authority. Certificate Authorities often get
hacked so be careful of equating a green lock to secure. Even with this
added layer of security, the united states government has recently
issued a request for everyone to upgrade their DNS to DNSSec which
includes additional security-focused technologies to verify with high
probability that an IP address is truly associated with a hostname.</p>
<p>Digression aside, DNS works like this in a nutshell</p>
<ol>
  <li>
    <p>Send a UDP packet to your DNS server</p>
  </li>
  <li>
    <p>If that DNS server has the packet cached return the result</p>
  </li>
  <li>
    <p>If not, ask higher-level DNS servers for the answer. Cache and send
the result</p>
  </li>
  <li>
    <p>If either packet is not answered from within a guessed timeout,
resend the request.</p>
  </li>
</ol>
<p>If you want the full bits and pieces, feel free to look at the Wikipedia
page. In essence, there is a hierarchy of DNS servers. First, there is
the dot hierarchy. This hierarchy first resolves top-level domains
<code class="language-plaintext highlighter-rouge">.edu</code> <code class="language-plaintext highlighter-rouge">.gov</code> etc. Next, it resolves the next level i.e. <code class="language-plaintext highlighter-rouge">illinois.edu</code>.
Then the local resolvers can resolve any number of URLs. For example,
the Illinois DNS server handles both <code class="language-plaintext highlighter-rouge">cs.illinois.edu</code> and
<code class="language-plaintext highlighter-rouge">cs341.cs.illinois.edu</code>. There is a limit on how many subdomains you can
have, but this is often used to route requests to different servers to
avoid having to buy many high performant servers to route requests.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="non-blocking-io" class="title-text">Non-Blocking IO<a class="anchor title-text" href="#non-blocking-io"> #</a>
</h2></div>





























































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>When you call <code class="language-plaintext highlighter-rouge">read()</code> if the data is unavailable, it will wait until
the data is ready before the function returns. When you’re reading data
from a disk, that delay is short, but when you’re reading from a slow
network connection, requests take a long time. And the data may never
arrive, leading to an unexpected close.</p>
<p>POSIX lets you set a flag on a file descriptor such that any call to
<code class="language-plaintext highlighter-rouge">read()</code> on that file descriptor will return immediately, whether it has
finished or not. With your file descriptor in this mode, your call to
<code class="language-plaintext highlighter-rouge">read()</code> will start the read operation, and while it’s working you can
do other useful work. This is called “non-blocking” mode since the call
to <code class="language-plaintext highlighter-rouge">read()</code> doesn’t block.</p>
<p>To set a file descriptor to be non-blocking.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// fd is my file descriptor</span>
<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
</code></pre></div></div>
<p>For a socket, you can create it in non-blocking mode by adding
<code class="language-plaintext highlighter-rouge">SOCK_NONBLOCK</code> to the second argument to <code class="language-plaintext highlighter-rouge">socket()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>When a file is in non-blocking mode and you call <code class="language-plaintext highlighter-rouge">read()</code>, it will
return immediately with whatever bytes are available. Say 100 bytes have
arrived from the server at the other end of your socket and you call
<code class="language-plaintext highlighter-rouge">read(fd, buf, 150)</code>. ‘read‘ will return immediately with a value of
100, meaning it read 100 of the 150 bytes you asked for. Say you tried
to read the remaining data with a call to <code class="language-plaintext highlighter-rouge">read(fd, buf+100, 50)</code>, but
the last 50 bytes still hadn’t arrived yet. <code class="language-plaintext highlighter-rouge">read()</code> would return -1 and
set the global error variable <strong>errno</strong> to either <code class="language-plaintext highlighter-rouge">EAGAIN</code> or
<code class="language-plaintext highlighter-rouge">EWOULDBLOCK</code>. That’s the system’s way of telling you the data isn’t
ready yet.</p>
<p><code class="language-plaintext highlighter-rouge">write()</code> also works in non-blocking mode. Say you want to send 40,000
bytes to a remote server using a socket. The system can only send so
many bytes at a time. In non-blocking mode, <code class="language-plaintext highlighter-rouge">write(fd, buf, 40000)</code>
would return the number of bytes it was able to send immediately, or
about 23,000. If you called <code class="language-plaintext highlighter-rouge">write()</code> right away again, it would return
-1 and set errno to <code class="language-plaintext highlighter-rouge">EAGAIN</code> or <code class="language-plaintext highlighter-rouge">EWOULDBLOCK</code>. That’s the system’s way
of telling you that it’s still busy sending the last chunk of data and
isn’t ready to send more yet.</p>
<p>There are a few ways to check that your IO has arrived. Let’s see how to
do it using <em>select</em> and <em>epoll</em>. The first interface we have is select.
It isn’t preferred by many in the POSIX community if they have an
alternative to it, and in most cases there is an alternative to it.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span>
<span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span>
<span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span>
<span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span>
<span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div></div>
<p>Given three sets of file descriptors, <code class="language-plaintext highlighter-rouge">select()</code> will wait for any of
those file descriptors to become ‘ready’.</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">readfds</code> - a file descriptor in <code class="language-plaintext highlighter-rouge">readfds</code> is ready when there is
data that can be read or EOF has been reached.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">writefds</code> - a file descriptor in <code class="language-plaintext highlighter-rouge">writefds</code> is ready when a call to
write() will succeed.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">exceptfds</code> - system-specific, not well-defined. Just pass NULL for
this.</p>
  </li>
</ol>
<p><code class="language-plaintext highlighter-rouge">select()</code> returns the total number of ready file descriptors. If none
of them become ready during the time defined by <em>timeout</em>, it will
return 0. After <code class="language-plaintext highlighter-rouge">select()</code> returns, the caller will need to loop through
the file descriptors in readfds and/or writefds to see which ones are
ready. As readfds and writefds act as both input and output parameters,
when <code class="language-plaintext highlighter-rouge">select()</code> indicates that there are ready file descriptors, it
would have overwritten them to reflect only the ready file descriptors.
Unless the caller intends to call <code class="language-plaintext highlighter-rouge">select()</code> only once, it would be a
good idea to save a copy of readfds and writefds before calling it. Here
is a comprehensive snippet.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fd_set</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">writefds</span><span class="p">;</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writefds</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">read_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">write_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timeval</span> <span class="n">timeout</span><span class="p">;</span>
<span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">timeout</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">num_ready</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">FD_SETSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"error in select()"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"timeout</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">read_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">))</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"fd %d is ready for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_read_fds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">write_fd_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">))</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"fd %d is ready for writing</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_write_fds</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html" class="fancy-link wiki-link">http://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html</a>
The problem with select and why a lot of users don’t use this or poll is
that select must linearly go through each of the objects. If at any
point in going through the objects, the previous objects change state,
select must restart. This is highly inefficient if we have a large
number of file descriptors in each of our sets. There is an alternative,
that isn’t much better.</p>
<h3 id="epoll" class="title-text">epoll</h3>
<p><code class="language-plaintext highlighter-rouge">epoll</code> is not part of POSIX, but it is supported by Linux. It is a more
efficient way to wait for many file descriptors. It will tell you
exactly which descriptors are ready. It even gives you a way to store a
small amount of data with each descriptor, like an array index or a
pointer, making it easier to access your data associated with that
descriptor.</p>
<p>First, you must create a special file descriptor with
<a href="http://linux.die.net/man/2/epoll_create" class="fancy-link wiki-link">http://linux.die.net/man/2/epoll_create</a>.
You won’t read or write to this file descriptor. You’ll pass it to the
other epoll_xxx functions and call close() on it at the end.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>For each file descriptor that you want to monitor with epoll, you’ll
need to add it to the epoll data structures using
<a href="http://linux.die.net/man/2/epoll_ctl" class="fancy-link wiki-link">http://linux.die.net/man/2/epoll_ctl</a>
with the <code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code> option. You can add any number of file
descriptors to it.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>  <span class="c1">// EPOLLIN==read, EPOLLOUT==write</span>
<span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">mypointer</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">)</span>
</code></pre></div></div>
<p>To wait for some of the file descriptors to become ready, use
<a href="http://linux.die.net/man/2/epoll_wait" class="fancy-link wiki-link">http://linux.die.net/man/2/epoll_wait</a>.
The epoll_event struct that it fills out will contain the data you
provided in event.data when you added this file descriptor. This makes
it easy for you to look up your data associated with this file
descriptor.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num_ready</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">timeout_milliseconds</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_ready</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyData</span> <span class="o">*</span><span class="n">mypointer</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyData</span><span class="o">*</span><span class="p">)</span> <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"ready to write on %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Say you were waiting to write data to a file descriptor, but now you
want to wait to read data from it. Just use <code class="language-plaintext highlighter-rouge">epoll_ctl()</code> with the
<code class="language-plaintext highlighter-rouge">EPOLL_CTL_MOD</code> option to change the type of operation you’re
monitoring.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
<span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">mypointer</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</code></pre></div></div>
<p>To unsubscribe one file descriptor from epoll while leaving others
active, use <code class="language-plaintext highlighter-rouge">epoll_ctl()</code> with the <code class="language-plaintext highlighter-rouge">EPOLL_CTL_DEL</code> option.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">mypointer</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p>To shut down an epoll instance, close its file descriptor.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">close</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
</code></pre></div></div>
<p>Also to non-blocking <code class="language-plaintext highlighter-rouge">read()</code> and <code class="language-plaintext highlighter-rouge">write()</code>, any calls to <code class="language-plaintext highlighter-rouge">connect()</code> on
a non-blocking socket will also be non-blocking. To wait for the
connection to complete, use <code class="language-plaintext highlighter-rouge">select()</code> or epoll to wait for the socket
to be writable. There are reasons to use epoll over select but due to
interface, there are fundamental problems with doing
so.</p>
<p><a href="https://idea.popcount.org/2017-01-06-select-is-fundamentally-broken/" class="fancy-link wiki-link">https://idea.popcount.org/2017-01-06-select-is-fundamentally-broken/</a></p>
<h3 id="epoll-example" class="title-text">Epoll Example</h3>
<p>Let’s break down the epoll code in the man page. We’ll assume that we
have a prepared TCP server socket <code class="language-plaintext highlighter-rouge">int listen_sock</code>. The first thing we
have to do is create the epoll device.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epollfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The next step is to add the listen socket in level triggered
mode.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This file object will be `read` from (connect is technically a read operation)</span>
<span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">listen_sock</span><span class="p">;</span>

<span class="c1">// Add the socket in with all the other fds. Everything is a file descriptor</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_ctl: listen_sock"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Then in a loop, we wait and see if epoll has any events.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_EVENTS</span><span class="p">];</span>
<span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>If we get an event on a client socket, that means that the client has
data ready to be read, and we perform that operation. Otherwise, we need
to update our epoll structure with a new client.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">listen_sock</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">conn_sock</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listen_sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="c1">// Must set to non-blocking</span>
  <span class="n">setnonblocking</span><span class="p">(</span><span class="n">conn_sock</span><span class="p">);</span>

  <span class="c1">// We will read from this file, and we only want to return once</span>
  <span class="c1">// we have something to read from. We don't want to keep getting</span>
  <span class="c1">// reminded if there is still data left (edge triggered)</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">conn_sock</span><span class="p">;</span>
  <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">conn_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The function above is missing some error checking for brevity as well.
Note that this code is performant because we added the server socket in
level-triggered mode and we add each of the client file descriptors in
edge-triggered. Edge triggered mode leaves more calculations on the part
of the application – the application must keep reading or writing until
the file descriptor is out of bytes – but it prevents starvation. A more
efficient implementation would also add the listening socket in
edge-triggered to clear out the backlog of connections as well.</p>
<p>Please read through most of <code class="language-plaintext highlighter-rouge">man 7 epoll</code> before starting to program.
There are a lot of gotchas. Some of the more common ones will be
detailed below.</p>
<h3 id="assorted-epoll-gotchas" class="title-text">Assorted Epoll Gotchas</h3>
<p>There are several problems with using epoll. Here we will detail a few.</p>
<ol>
  <li>
    <p>There are two modes. Level triggered and edge-triggered. Level
triggered means that while the file descriptor has events on it, it
will be returned by epoll when calling the ctl function. In
edge-triggered, the caller will only get the file descriptor once it
goes from zero events to an event. This means if you forget to read,
write, accept etc on the file descriptor until you get a
EWOULDBLOCK, that file descriptor will be dropped.</p>
  </li>
  <li>
    <p>If at any point you duplicate a file descriptor and add it to epoll,
you will get an event from that file descriptor and the duplicated
one.</p>
  </li>
  <li>
    <p>You can add an epoll object to epoll. Edge triggered and
level-triggered modes are the same because ctl will reset the state
to zero events</p>
  </li>
  <li>
    <p>Depending on the conditions, you may get a file descriptor that was
closed from Epoll. This isn’t a bug. The reason that this happens is
epoll works on the kernel object level, not the file descriptor
level. If the kernel object lives longer and the right flags are
set, a process could get a closed file descriptor. This also means
that if you close the file descriptor, there is no way to remove the
kernel object.</p>
  </li>
  <li>
    <p>Epoll has the <code class="language-plaintext highlighter-rouge">EPOLLONESHOT</code> flag which will remove a file
descriptor after it has been returned in <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man2/epoll_wait.2.html" class="fancy-link">epoll_wait</a></code></p>
  </li>
  <li>
    <p>Epoll using level-triggered mode could starve certain file
descriptors because it is unknown how much data the application will
read from each descriptor.</p>
  </li>
</ol>
<p>Read more at <code class="language-plaintext highlighter-rouge">man 7 epoll</code> or check out a better version called <code class="language-plaintext highlighter-rouge">kqueue</code>
in the appendix.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="remote-procedure-calls" class="title-text">Remote Procedure Calls<a class="anchor title-text" href="#remote-procedure-calls"> #</a>
</h2></div>





















































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>RPC or Remote Procedure Call is the idea that we can execute a procedure
on a different machine. In practice, the procedure may execute on the
same machine. However, it may be in a different context. For example,
the operation under a different user with different permissions and
different lifecycles.</p>
<p>An example of this is you may send a remote procedure call to a docker
daemon to change the state of the container. Not every application needs
to have access to the entire system machine, but they should have access
to containers that they’ve created.</p>
<h3 id="privilege-separation" class="title-text">Privilege Separation</h3>
<p>The remote code will execute under a different user and with different
privileges from the caller. In practice, the remote call may execute
with more or fewer privileges than the caller. This in principle can be
used to improve the security of a system by ensuring components operate
with the least privilege. Unfortunately, security concerns need to be
carefully assessed to ensure that RPC mechanisms cannot be subverted to
perform unwanted actions. For example, an RPC implementation may
implicitly trust any connected client to perform any action, rather than
a subset of actions on a subset of the data.</p>
<h3 id="stub-code-and-marshaling" class="title-text">Stub Code and Marshaling</h3>
<p>The stub code is the necessary code to hide the complexity of performing
a remote procedure call. One of the roles of the stub code is to
<em>marshal</em> the necessary data into a format that can be sent as a byte
stream to a remote server.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// On the outside, 'getHiscore' looks like a normal function call</span>
<span class="c1">// On the inside, the stub code performs all of the work to send and receive data to and from the remote machine.</span>

<span class="kt">int</span> <span class="nf">getHighScore</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">game</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Marshal the request into a sequence of bytes:</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span><span class="s">"getHiscore(%s)!"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

  <span class="c1">// Send down the wire (we do not send the zero byte; the '!' signifies the end of the message)</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">);</span>

  <span class="c1">// Wait for the server to send a response</span>
  <span class="kt">ssize_t</span> <span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

  <span class="c1">// Example: unmarshal the bytes received back from text into an int</span>
  <span class="n">buffer</span><span class="p">[</span><span class="n">bytesread</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Turn the result into a C string</span>

  <span class="kt">int</span> <span class="n">score</span><span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">score</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Using a string format may be a little inefficient. A good example of
this marshaling is Golang’s gRPC or Google RPC. There is a version in C
as well if you want to check that out.</p>
<p>The server stub code will receive the request, unmarshal the request
into a valid in-memory data call the underlying implementation and send
the result back to the caller. Often the underlying library will do this
for you.</p>
<p>To implement RPC you need to decide and document which conventions you
will use to serialize the data into a byte sequence. Even a simple
integer has several common choices.</p>
<ol>
  <li>
    <p>Signed or unsigned?</p>
  </li>
  <li>
    <p>ASCII, Unicode Text Format 8, some other encoding?</p>
  </li>
  <li>
    <p>Fixed number of bytes or variable depending on the magnitude.</p>
  </li>
  <li>
    <p>Little or Big endian binary format if using binary?</p>
  </li>
</ol>
<p>To marshal a struct, decide which fields need to be serialized. It may
be unnecessary to send all data items. For example, some items may be
irrelevant to the specific RPC or can be re-computed by the server from
the other data items present.</p>
<p>To marshal a linked list, it is unnecessary to send the link pointers,
stream the values. As part of unmarshaling, the server can recreate a
linked list structure from the byte sequence.</p>
<p>By starting at the head node/vertex, a simple tree can be recursively
visited to create a serialized version of the data. A cyclic graph will
usually require additional memory to ensure that each edge and vertex is
processed exactly once.</p>
<h3 id="interface-description-language" class="title-text">Interface Description Language</h3>
<p>Writing stub code by hand is painful, tedious, error-prone, difficult to
maintain and difficult to reverse engineer the wire protocol from the
implemented code. A better approach is to specify the data objects,
messages, and services to automatically generate the client and server
code. A modern example of an Interface Description Language is Google’s
Protocol Buffer .proto files.</p>
<p>Even then, Remote Procedure Calls are significantly slower (10x to 100x)
and more complex than local calls. An RPC must marshal data into a
wire-compatible format. This may require multiple passes through the
data structure, temporary memory allocation, and transformation of the
data representation.</p>
<p>Robust RPC stub code must intelligently handle network failures and
versioning. For example, a server may have to process requests from
clients that are still running an early version of the stub code.</p>
<p>A secure RPC will need to implement additional security checks including
authentication and authorization, validate data and encrypt
communication between the client and host. A lot of the time, the RPC
system can do this efficiently for you. Consider if you have both an RPC
client and server on the same machine. Starting up a thrift or Google
RPC server could validate and route the request to a local socket which
wouldn’t be sent over the network.</p>
<h3 id="transferring-structured-data" class="title-text">Transferring Structured Data</h3>
<p>Let’s examine three methods of transferring data using 3 different
formats - JSON, XML, and Google Protocol Buffers. JSON and XML are
text-based protocols. Examples of JSON and XML messages are
below.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ticket&gt;&lt;price</span> <span class="na">currency=</span><span class="s">'dollar'</span><span class="nt">&gt;</span>10<span class="nt">&lt;/price&gt;&lt;vendor&gt;</span>travelocity<span class="nt">&lt;/vendor&gt;&lt;/ticket&gt;</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ 'currency':'dollar' , 'vendor':'travelocity', 'price':'10' }
</code></pre></div></div>
<p>Google Protocol Buffers is an open-source efficient binary protocol that
places a strong emphasis on high throughput with low CPU overhead and
minimal memory copying. This means client and server stub code in
multiple languages can be generated from the .proto specification file
to marshal data to and from a binary
stream.</p>
<p><a href="https://developers.google.com/protocol-buffers/docs/overview" class="fancy-link wiki-link">https://developers.google.com/protocol-buffers/docs/overview</a>
reduces the versioning problem by ignoring unknown fields that are
present in a message. See the introduction to Protocol Buffers for more
information.</p>
<p>The general chain is to abstract away the actual business logic and the
various marshaling code. If your application ever becomes CPU bound
parsing XML, JSON or YAML, switch to protocol buffers!</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics"> #</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>IPv4 vs IPv6</p>
  </li>
  <li>
    <p>TCP vs UDP</p>
  </li>
  <li>
    <p>Packet Loss/Connection Based</p>
  </li>
  <li>
    <p>Get address info</p>
  </li>
  <li>
    <p>DNS</p>
  </li>
  <li>
    <p>TCP client calls</p>
  </li>
  <li>
    <p>TCP server calls</p>
  </li>
  <li>
    <p>shutdown</p>
  </li>
  <li>
    <p>recvfrom</p>
  </li>
  <li>
    <p>epoll vs select</p>
  </li>
  <li>
    <p>RPC</p>
  </li>
</ul></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions"> #</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<ul>
  <li>
    <p>What is IPv4? IPv6? What are the differences between them?</p>
  </li>
  <li>
    <p>What is the TCP? The UDP? Give me the advantages and disadvantages
of both of them. What is a scenario of using one over the other?</p>
  </li>
  <li>
    <p>Which protocol is connectionless and which one is connection based?</p>
  </li>
  <li>
    <p>What is DNS? What is the route that DNS takes?</p>
  </li>
  <li>
    <p>What does socket do?</p>
  </li>
  <li>
    <p>What are the calls to set up a TCP client?</p>
  </li>
  <li>
    <p>What are the calls to set up a TCP server?</p>
  </li>
  <li>
    <p>What is the difference between a socket shutdown and closing?</p>
  </li>
  <li>
    <p>When can you use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>? How about <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/recvfrom.3p.html" class="fancy-link">recvfrom</a></code> and
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sendto.3p.html" class="fancy-link">sendto</a></code>?</p>
  </li>
  <li>
    <p>What are some advantages to <code class="language-plaintext highlighter-rouge">epoll</code> over <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/select.3p.html" class="fancy-link">select</a></code>? How about
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/select.3p.html" class="fancy-link">select</a></code> over <code class="language-plaintext highlighter-rouge">epoll</code>?</p>
  </li>
  <li>
    <p>What is a remote procedure call? When should one use it versus HTTP
or running code locally?</p>
  </li>
  <li>
    <p>What is marshaling/unmarshaling? Why is HTTP <em>not</em> an RPC?</p>
  </li>
</ul>
<div id="refs" class="references">

<div id="ref-cohen_1980">

Cohen, Danny. 1980. “ON Holy Wars and a Plea for Peace.” *IETF*. IETF.
<a href="https://www.ietf.org/rfc/ien/ien137.txt" class="fancy-link wiki-link">https://www.ietf.org/rfc/ien/ien137.txt</a>.

</div>

<div id="ref-rfc7231">

Fielding, Roy T., and Julian Reschke. 2014. “Hypertext Transfer Protocol
(HTTP/1.1): Semantics and Content.” Request for Comments. RFC 7231; RFC
Editor.
<a href="https://doi.org/10.17487/RFC7231" class="fancy-link wiki-link">https://doi.org/10.17487/RFC7231</a>.

</div>

<div id="ref-RFC1700">

Reynolds, J., and J. Postel. 1994. “Assigned Numbers.” RFC 1700. RFC
Editor; Internet Requests for Comments; RFC Editor.

</div>

<div id="ref-internet_society_2018">

“State of Ipv6 Deployment 2018.” 2018. *Internet Society*. Internet
Society.
<a href="https://www.internetsociety.org/resources/2018/state-of-ipv6-deployment-2018/" class="fancy-link wiki-link">https://www.internetsociety.org/resources/2018/state-of-ipv6-deployment-2018/</a>.

</div>

<div id="ref-rfc768">

“User Datagram Protocol.” 1980. Request for Comments. RFC 768; RFC
Editor.
<a href="https://doi.org/10.17487/RFC0768" class="fancy-link wiki-link">https://doi.org/10.17487/RFC0768</a>.

</div>

</div>
</div></div></div>
</div></div>
</div>
            
            <div class="wrapper">
</div>
          </div>
          <div class="col-md-2 col-sm-1 col-xs-0"></div>
        </div>
        <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Bring in JQuery and Bootstrap -->
<script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" crossorigin="anonymous"></script>
<!-- For table of content -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script src="/js/scroll.js"></script>
<footer class="">

<!-- Add another container at the bottom so there is some space there -->
<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

      </div>
    </div>
  </div>
  <script type="application/javascript">
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_coursebook/Networking.md";
  </script>
</body>

</html>