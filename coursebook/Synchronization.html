<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>CS 341 · Synchronization</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <!-- For table of content  -->

  <link rel="stylesheet" href="/css/code-style.css"/>
  <link rel="stylesheet" href="/css/main.css"/>
  <link rel="stylesheet" href="/css/bootstrap-toc.css"/>

  <meta property="og:locale" content="en_US">

  
  <meta property="og:title" content="Synchronization" />
  

  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://cs341.cs.illinois.edu" />

  
  <meta property="og:description" content=""Webpage for CS 341: System Programming at the University of Illinois Urbana-Champaign. All documentation and information about the course can be found here."
" />
  

</head>


<body data-spy="scroll" data-target="#overview" data-offset="50">
  <div class="container-fluid">
    <div class="row" style="display: flex; justify-content: stretch;">
      <!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <!-- Navigation button as html so we don't have to resize images -->
      <button
        type="button"
        class="navbar-toggle collapsed"
        data-toggle="collapse"
        data-target=".navbar-collapse"
        aria-expanded="false"
        aria-controls="navbar"
      >
        <!-- Hamburger Navigation bar on small -->
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Full title on laptop -->
      <a class="navbar-brand navbar-item normal" href="/">
             <span>CS 341: System Programming</span> 
      </a>

      <!-- Smaller on mobile-->
      <a class="navbar-brand navbar-item small" href="/">
          <span>CS 341</span>
      </a>
    </div>

    <!-- Finally generate what is in the navbar -->
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
        <li class="navbar-item">
          <a href="/assignments.html">Assignments</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/quiz_topics.html">Quizzes</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/grades.html">Grades</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/schedule.html">Lectures</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/syllabus.html">Syllabus</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/staff.html">Staff</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/resources.html">Resources</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="/peer_tutoring.html">Peer Tutoring</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/coursebook/index.html">Coursebook</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="">Lecture Materials</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/tutorials/development">Linux Virtual Machine</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/honors.html">Honors</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
      </ul>
    </div>
  </div>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Roboto"
    rel="stylesheet"
  />
</nav>

      <div class="row">
        <div class="col-sm-3 col-xs-12 hidden-xs" style="min-height: 100%">
          <nav id="overview" data-toggle="toc" class="sticky-top"></nav>
        </div>
        <div class="col-sm-9 col-xs-12">
          <div class="title">
            
            
            
            <h1>
              Synchronization
            </h1>
          </div>
          <div class="content col-sm-11 .col-sm-offset-1">
            
          </div>
          <div class="hidden-sm hidden-md hidden-lg">
            
          </div>
          <div id="content">
            


            <div class="wrapper">
<ul>
  <li>
<a href="#synchronization" class="fancy-link wiki-link">Synchronization</a>
    <ul>
      <li>
<a href="#mutex" class="fancy-link wiki-link">Mutex</a>
        <ul>
          <li><a href="#mutex-lifetime" class="fancy-link wiki-link">Mutex Lifetime</a></li>
          <li><a href="#mutex-usages" class="fancy-link wiki-link">Mutex Usages</a></li>
          <li><a href="#mutex-implementation" class="fancy-link wiki-link">Mutex Implementation</a></li>
          <li><a href="#advanced-implementing-a-mutex-with-hardware" class="fancy-link wiki-link">Advanced: Implementing a Mutex with
hardware</a></li>
          <li><a href="#semaphore" class="fancy-link wiki-link">Semaphore</a></li>
        </ul>
      </li>
      <li><a href="#condition-variables" class="fancy-link wiki-link">Condition Variables</a></li>
      <li>
<a href="#thread-safe-data-structures" class="fancy-link wiki-link">Thread-Safe Data Structures</a>
        <ul>
          <li><a href="#using-semaphores" class="fancy-link wiki-link">Using Semaphores</a></li>
        </ul>
      </li>
      <li>
<a href="#software-solutions-to-the-critical-section" class="fancy-link wiki-link">Software Solutions to the Critical
Section</a>
        <ul>
          <li><a href="#naive-solutions" class="fancy-link wiki-link">Naive Solutions</a></li>
          <li><a href="#turn-based-solutions" class="fancy-link wiki-link">Turn-based solutions</a></li>
          <li><a href="#turn-and-flag-solutions" class="fancy-link wiki-link">Turn and Flag solutions</a></li>
        </ul>
      </li>
      <li>
<a href="#working-solutions" class="fancy-link wiki-link">Working Solutions</a>
        <ul>
          <li><a href="#petersons-solution" class="fancy-link wiki-link">Peterson’s Solution</a></li>
        </ul>
      </li>
      <li>
<a href="#implementing-counting-semaphore" class="fancy-link wiki-link">Implementing Counting
Semaphore</a>
        <ul>
          <li><a href="#other-semaphore-considerations" class="fancy-link wiki-link">Other semaphore
considerations</a></li>
        </ul>
      </li>
      <li>
<a href="#barriers" class="fancy-link wiki-link">Barriers</a>
        <ul>
          <li><a href="#reader-writer-problem" class="fancy-link wiki-link">Reader Writer Problem</a></li>
          <li><a href="#attempt-1" class="fancy-link wiki-link">Attempt #1</a></li>
          <li><a href="#attempt-2" class="fancy-link wiki-link">Attempt #2:</a></li>
          <li><a href="#attempt-3" class="fancy-link wiki-link">Attempt #3</a></li>
          <li><a href="#starving-writers" class="fancy-link wiki-link">Starving writers</a></li>
          <li><a href="#attempt-4" class="fancy-link wiki-link">Attempt #4</a></li>
        </ul>
      </li>
      <li>
<a href="#ring-buffer" class="fancy-link wiki-link">Ring Buffer</a>
        <ul>
          <li><a href="#ring-buffer-gotchas" class="fancy-link wiki-link">Ring Buffer Gotchas</a></li>
          <li><a href="#multithreaded-correctness" class="fancy-link wiki-link">Multithreaded Correctness</a></li>
          <li><a href="#analysis" class="fancy-link wiki-link">Analysis</a></li>
          <li><a href="#another-analysis" class="fancy-link wiki-link">Another Analysis</a></li>
          <li><a href="#correct-implementation-of-a-ring-buffer" class="fancy-link wiki-link">Correct implementation of a ring
buffer</a></li>
        </ul>
      </li>
      <li>
<a href="#extra-process-synchronization" class="fancy-link wiki-link">Extra: Process Synchronization</a>
        <ul>
          <li><a href="#interruption" class="fancy-link wiki-link">Interruption</a></li>
          <li><a href="#solution" class="fancy-link wiki-link">Solution</a></li>
        </ul>
      </li>
      <li><a href="#external-resources" class="fancy-link wiki-link">External Resources</a></li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p><span> </span></p>



<p><strong>When multithreading gets interesting</strong> - <em>**</em></p>

<p>Synchronization coordinates various tasks so that they all finishin the
the correct state. In C, we have series of mechanisms to control what
threads are allowed to perform at a given state. Most of the time, the
threads can progress without having to communicate, but every so often
two or more threads may want to access a critical section. A critical
section is a section of code that can only be executed by one thread at
a time if the program is to function correctly. If two threads (or
processes) were to execute code inside the critical section at the same
time, it is possible that the program may no longer have the correct
behavior.</p>

<p>As we said in the previous chapter, race conditions happen when an
operation touches a piece of memory at the same time as another thread.
If the memory location is only accessible by one thread, for example the
automatic variable <code class="language-plaintext highlighter-rouge">i</code> below, then there is no possibility of a race
condition and no Critical Section associated with <code class="language-plaintext highlighter-rouge">i</code>. However, the
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/sum.1.html" class="fancy-link">sum</a></code> variable is a global variable and accessed by two threads. It is
possible that two threads may attempt to increment the variable at the
same time.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//shared</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">countgold</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//local to each thread</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">//Wait for both threads to finish:</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"ARRRRG sum is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A typical output of the above code is <code class="language-plaintext highlighter-rouge">ARGGGH sum is &lt;some number less
than expected&gt;</code> because there is a race condition. The code allows two
threads to read and write <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/sum.1.html" class="fancy-link">sum</a></code> at the same time. For example, both
threads copy the current value of sum into CPU that runs each thread
(let’s pick 123). Both threads increment one to their own copy. Both
threads write back the value (124). If the threads had accessed the sum
at different times then the count would have been 125. A few of the
possible different orderings are below.</p>

<p>Permissible Pattern</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">…</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">…</td>
    </tr>
    <tr>
      <td style="text-align: left">…</td>
      <td style="text-align: right">Load Addr, Add 1 (i=2 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">…</td>
      <td style="text-align: right">Store (i=2 globally)</td>
    </tr>
  </tbody>
</table>

<p>Good Thread Access Pattern</p>

<p>Partial Overlap</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">…</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">Load Addr, Add 1 (i=1 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">…</td>
      <td style="text-align: right">Store (i=1 globally)</td>
    </tr>
  </tbody>
</table>

<p>Bad Thread Access Pattern</p>

<p>Full Overlap</p>

<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Thread 1</th>
      <th style="text-align: right">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Load Addr, Add 1 (i=1 locally)</td>
      <td style="text-align: right">Load Addr, Add 1 (i=1 locally)</td>
    </tr>
    <tr>
      <td style="text-align: left">Store (i=1 globally)</td>
      <td style="text-align: right">Store (i=1 globally)</td>
    </tr>
  </tbody>
</table>

<p>Horrible Thread Access Pattern</p>

<p>We would like the first pattern of the code being mutually exclusive.
Which leads us to our first synchronization primitive, a Mutex.</p>

<div class="pad"><div class="card">
<div class="title"><h2 id="mutex" class="title-text">Mutex<a class="anchor title-text" href="#mutex"> #</a>
</h2></div>

































































































<!-- end list -->













<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>To ensure that only one thread at a time can access a global variable,
use a mutex – short for Mutual Exclusion. If one thread is currently
inside a critical section we would like another thread to wait until the
first thread is complete. A mutex isn’t a primitive in the truest sense,
though it is one of the smallest that has useful threading API. A mutex
also isn’t a data structure. It is an abstract data type.</p>
<p>Let’s think about a duck satisfying the mutex api. If someone has the
duck then they are allowed to access a shared resource! We call it the
mutex duck. Everyone else has to waddle around and wait. Once someone
let’s go of the duck, they have to stop interacting with the resource
and the next grabber can interact with the shared resource. Now you know
the origins of the duck.</p>
<p>There are many ways to implement a mutex, and we’ll give a few in this
chapter. For right now let’s use the black box that the pthread library
gives us. Here is how we declare a mutex.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// start of Critical Section</span>
<span class="c1">// Critical section</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">//end of Critical Section</span>
</code></pre></div></div>
<h3 id="mutex-lifetime" class="title-text">Mutex Lifetime</h3>
<p>For all mutexes, there are two ways of initializing a mutex:</p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t
*attr)</code></p>
  </li>
</ul>
<p>The macro <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> is functionally equivalent to the
more general purpose <code class="language-plaintext highlighter-rouge">pthread_mutex_init(&amp;m,NULL)</code>. In other words,
<code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> will create a mutex with default properties.
The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/attr.1.html" class="fancy-link">attr</a></code> in the init version includes options to trade performance for
additional error-checking, advanced sharing, and more. While we
recommend using the init function inside of a program for a mutex
located on the heap, you can use either method.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">));</span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//later</span>
<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>
<p>Once we are finished with the mutex we should also call
<code class="language-plaintext highlighter-rouge">pthread_mutex_destroy(&amp;m)</code> too. Note, a program can only destroy an
unlocked mutex, destroy on a locked mutex is undefined behavior. Things
to keep in mind about initializing and destroying mutexes:</p>
<ol>
  <li>
    <p>Initializing an already initialized mutex is undefined behavior</p>
  </li>
  <li>
    <p>Destroying a locked mutex is undefined behavior</p>
  </li>
  <li>
    <p>Keep to the pattern of one and only one thread initializing a mutex.</p>
  </li>
  <li>
    <p>Copying the bytes of the mutex to a new memory location and then
using the copy is <em>not</em> supported. To reference a mutex, a program
<em>must</em> to have a pointer to that memory address.</p>
  </li>
  <li>
    <p>Global/Static mutexes need not be destroyed.</p>
  </li>
</ol>
<h3 id="mutex-usages" class="title-text">Mutex Usages</h3>
<p>How does one use a mutex? Here is a complete example in the spirit of
the earlier piece of code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>
<span class="c1">// Create a global mutex, this is ready to be locked!</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">countgold</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">//Same thread that locks the mutex must unlock it</span>
  <span class="c1">//Critical section is 'sum += 1'</span>
  <span class="c1">//However locking and unlocking ten million times</span>
  <span class="c1">//has significant overhead</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="c1">// Other threads that call lock will have to wait until we call unlock</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">countgold</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"ARRRRG sum is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the code above, the thread gets the lock to the counting house before
entering. The critical section is only the <code class="language-plaintext highlighter-rouge">sum+=1</code> so the following
version is also correct.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This process runs slower because we lock and unlock the mutex a million
times, which is expensive - at least compared with incrementing a
variable. In this simple example, we didn’t need threads - we could have
added up twice! A faster multi-thread example would be to add one
million using an automatic (local) variable and only then adding it to a
shared total after the calculation loop has finished:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">local</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="n">sum</span> <span class="o">+=</span> <span class="n">local</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>Starting with the gotchas. Firstly, C Mutexes do not lock variables. A
mutex is a simple data structure. It works with code, not data. If a
mutex is locked, the other threads will continue. It’s only when a
thread attempts to lock a mutex that is already locked, will the thread
have to wait. As soon as the original thread unlocks the mutex, the
second (waiting) thread will acquire the lock and be able to continue.
The following code creates a mutex that does effectively nothing.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">,</span>
<span class="n">m2</span> <span class="o">=</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="c1">// later</span>
<span class="c1">// Thread 1</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
<span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
</code></pre></div></div>
<p>Here are some other gotchas in no particular order</p>
<ol>
  <li>
    <p>Don’t cross the streams! If using threads, don’t fork in the middle
of your program. This means any time after your mutexes have been
initialized.</p>
  </li>
  <li>
    <p>The thread that locks a mutex is the only thread that can unlock it.</p>
  </li>
  <li>
    <p>Each program can have multiple mutex locks. A thread safe design
might include a lock with each data structure, one lock per heap, or
one lock per set of data structures If a program has only one lock,
then there may be significant contention for the lock. If two
threads were updating two different counters, it isn’t necessary to
use the same lock.</p>
  </li>
  <li>
    <p>Locks are only tools. They don’t spot critical sections!</p>
  </li>
  <li>
    <p>There will always be a small amount of overhead of calling
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_lock.3p.html" class="fancy-link">pthread_mutex_lock</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_unlock.3p.html" class="fancy-link">pthread_mutex_unlock</a></code>. However, this is
the price to pay for correctly functioning programs!</p>
  </li>
  <li>
    <p>Not unlocking a mutex due to an early return during an error
condition</p>
  </li>
  <li>
    <p>Resource leak (not calling <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_destroy.3p.html" class="fancy-link">pthread_mutex_destroy</a></code>)</p>
  </li>
  <li>
    <p>Using an uninitialized mutex or using a mutex that has already been
destroyed</p>
  </li>
  <li>
    <p>Locking a mutex twice on a thread without unlocking first</p>
  </li>
  <li>
    <p>Deadlock</p>
  </li>
</ol>
<h3 id="mutex-implementation" class="title-text">Mutex Implementation</h3>
<p>So we have this cool data structure. How do we implement it? A naive,
incorrect implementation is shown below. The <code class="language-plaintext highlighter-rouge">unlock</code> function simply
unlocks the mutex and returns. The lock function first checks to see if
the lock is already locked. If it is currently locked, it will keep
checking again until another thread has unlocked the mutex. For the time
being, we’ll avoid the condition that other threads are able to unlock a
lock they don’t own and focus on the mutual exclusion aspect.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Version 1 (Incorrect!)</span>

<span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*Locked? Never-mind - loop and check again!*/</span> <span class="p">}</span>

  <span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 1 uses ‘busy-waiting’ unnecessarily wasting CPU resources.
However, there is a more serious problem. We have a race-condition! If
two threads both called <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man2/lock.2.html" class="fancy-link">lock</a></code> concurrently, it is possible that both
threads would read <code class="language-plaintext highlighter-rouge">m_locked</code> as zero. Thus both threads would believe
they have exclusive access to the lock and both threads will continue.</p>
<p>We might attempt to reduce the CPU overhead a little by calling
<code class="language-plaintext highlighter-rouge">pthread_yield()</code> inside the loop - pthread_yield suggests to the
operating system that the thread does not use the CPU for a short while,
so the CPU may be assigned to threads that are waiting to run. This
still leaves the race-condition. We need a better implementation. We
will talk about this later in the critical section part of this chapter.
For now, we will talk about semaphores.</p>
<h3 id="advanced-implementing-a-mutex-with-hardware" class="title-text">Advanced: Implementing a Mutex with hardware</h3>
<p>We can use C11 Atomics to do that perfectly! A complete solution is
detailed here. This is a spinlock mutex,
<a href="https://locklessinc.com/articles/mutex_cv_futex/" class="fancy-link wiki-link">https://locklessinc.com/articles/mutex_cv_futex/</a>
implementations can be found online.</p>
<p>First the data structure and initialization code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">mutex_</span><span class="p">{</span>
  <span class="c1">// We need some variable to see if the lock is locked</span>
  <span class="n">atomic_int_least8_t</span> <span class="n">lock</span><span class="p">;</span>
  <span class="c1">// A mutex needs to keep track of its owner so</span>
  <span class="c1">// Another thread can't unlock it</span>
  <span class="n">pthread_t</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span> <span class="n">mutex</span><span class="p">;</span>

<span class="cp">#define UNLOCKED 0
#define LOCKED 1
#define UNASSIGNED_OWNER 0
</span>
<span class="kt">int</span> <span class="nf">mutex_init</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="c1">// Some simple error checking</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mtx</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Not thread-safe the user has to take care of this</span>
  <span class="n">atomic_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">UNASSIGNED_OWNER</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is the initialization code, nothing fancy here. We set the state of
the mutex to unlocked and set the owner to locked.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="kt">int_least8_t</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">UNLOCKED</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_compare_exchange_weak_explicit</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
  <span class="n">LOCKED</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">)){</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">UNLOCKED</span><span class="p">;</span>
    <span class="n">sched_yield</span><span class="p">();</span> <span class="c1">// Use system calls for scheduling speed</span>
  <span class="p">}</span>
  <span class="c1">// We have the lock now</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What does this code do? It initializes a variable that we will keep as
the unlocked state.
<a href="https://en.wikipedia.org/wiki/Compare-and-swap" class="fancy-link wiki-link">https://en.wikipedia.org/wiki/Compare-and-swap</a>
is an instruction supported by most modern architectures (on x86 it’s
<code class="language-plaintext highlighter-rouge">lock cmpxchg</code>). The pseudocode for this operation looks like this</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">atomic_compare_exchange_pseudo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">addr1</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">addr2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">addr1</span> <span class="o">==</span> <span class="o">*</span><span class="n">addr2</span><span class="p">){</span>
    <span class="o">*</span><span class="n">addr1</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="o">*</span><span class="n">addr2</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Except it is all done <em>atomically</em> meaning in one uninterruptible
operation. What does the <em>weak</em> part mean? Atomic instructions are prone
to <strong>spurious failures</strong> meaning that there are two versions to these
atomic functions a <em>strong</em> and a <em>weak</em> part, strong guarantees the
success or failure while weak may fail even when the operation succeeds.
These are the same spurious failures that you’ll see in condition
variables below. We are using weak because weak is faster, and we are in
a loop! That means we are okay if it fails a little bit more often
because we will keep spinning around anyway.</p>
<p>Inside the while loop, we have failed to grab the lock! We reset zero
to unlocked and sleep for a little while. When we wake up we try to grab
the lock again. Once we successfully swap, we are in the critical
section! We set the mutex’s owner to the current thread for the unlock
method and return successfully.</p>
<p>How does this guarantee mutual exclusion? When working with atomics we
are unsure! But in this simple example, we can because the thread that
can successfully expect the lock to be UNLOCKED (0) and swap it to a
LOCKED (1) state is considered the winner. How do we implement unlock?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="o">*</span> <span class="n">mtx</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)){</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Can't unlock a mutex if the thread isn't the owner</span>
  <span class="p">}</span>
  <span class="kt">int_least8_t</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">//Critical section ends after this atomic</span>
  <span class="n">mtx</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">UNASSIGNED_OWNER</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_compare_exchange_strong_explicit</span><span class="p">(</span>
  <span class="o">&amp;</span><span class="n">mtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
  <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span>
  <span class="n">UNLOCKED</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">,</span>
  <span class="n">memory_order_seq_cst</span><span class="p">)){</span>
    <span class="c1">//The mutex was never locked in the first place</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To satisfy the API, a thread can’t unlock the mutex unless the thread is
the one who owns it. Then we unassign the mutex owner, because critical
section is over after the atomic. We want a strong exchange because we
don’t want to block. We expect the mutex to be locked, and we swap it to
unlock. If the swap was successful, we unlocked the mutex. If the swap
wasn’t, that means that the mutex was UNLOCKED and we tried to switch it
from UNLOCKED to UNLOCKED, preserving the behavior of unlock.</p>
<p>What is this memory order business? We were talking about memory fences
earlier, here it is! We won’t go into detail because it is outside the
scope of this course but in the scope of
<a href="https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync" class="fancy-link wiki-link">https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</a>.
We need consistency to make sure no loads or stores are ordered before
or after. A program need to create dependency chains for more efficient
ordering.</p>
<h3 id="semaphore" class="title-text">Semaphore</h3>
<p>A semaphore is another synchronization primitive. It is initialized to
some value. Threads can either <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code> or <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> which lowers or
increases the value. If the value reaches zero and a wait is called, the
thread will be blocked until a post is called.</p>
<p>Using a semaphore is as easy as using a mutex. First, decide if on the
initial value, for example the number of remaining spaces in an array.
Unlike pthread mutex there are no shortcuts to creating a semaphore -
use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_init.3p.html" class="fancy-link">sem_init</a></code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span>
<span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// returns -1 (=FAILED) on OS X</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Could do this 10 times without blocking</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Announce that we've finished (and one more resource item is available; increment count)</span>
  <span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="c1">// release resources of the semaphore</span>
<span class="p">}</span>
</code></pre></div></div>
<p>When using a semaphore, wait and post can be called from different
threads! Unlike a mutex, the increment and decrement can be from
different threads.</p>
<p>This becomes especially useful if you want to use a semaphore to
implement a mutex. A mutex is a semaphore that always <code class="language-plaintext highlighter-rouge">waits</code> before it
<code class="language-plaintext highlighter-rouge">posts</code>. Some textbooks will refer to a mutex as a binary semaphore. You
do have to be careful to never add more than one to a semaphore or
otherwise your mutex abstraction breaks. That is usually why a mutex is
used to implement a semaphore and vice versa.</p>
<ul>
  <li>
    <p>Initialize the semaphore with a count of one.</p>
  </li>
  <li>
    <p>Replace <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_lock.3p.html" class="fancy-link">pthread_mutex_lock</a></code> with <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code></p>
  </li>
  <li>
    <p>Replace <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_unlock.3p.html" class="fancy-link">pthread_mutex_unlock</a></code> with <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code></p>
  </li>
</ul>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>But be warned, it isn’t the same! A mutex can handle what we call lock
inversion well. Meaning the following code breaks with a traditional
mutex, but produces a race condition with threads.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thread 1</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="c1">// Some threads want to see the world burn</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 3</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Not thread-safe!</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>If we replace it with mutex lock, it won’t work now.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Thread 1</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Critical Section</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 2</span>
<span class="c1">// Foiled!</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="c1">// Thread 3</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="c1">// Now it's thread-safe</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div>
<p>Also, binary semaphores are different than mutexes because one thread
can unlock a mutex from a different thread.</p>
<div class="pad"><div class="card">
<h4 id="signal-safety">Signal Safety</h4>

<p>Also, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> is one of a handful of functions that can be correctly
used inside a signal handler <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_unlock.3p.html" class="fancy-link">pthread_mutex_unlock</a></code> is not. We can
release a waiting thread that can now make all of the calls that we
disallowed to call inside the signal handler itself e.g. <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/printf.h.3head.html" class="fancy-link">printf</a></code>. Here
is some code that utilizes this;</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* Release the Kraken! */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">singsong</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting until a signal releases...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* Initial value of zero*/</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"Could not create unnamed semaphore"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <span class="c1">// Too simple! See Signals chapter</span>

  <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">singsong</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* Process will exit when there are no more threads */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Other uses for semaphores are keeping track of empty spaces in arrays.
We will discuss these in the thread-safe data structures section.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="condition-variables" class="title-text">Condition Variables<a class="anchor title-text" href="#condition-variables"> #</a>
</h2></div>









<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Condition variables allow a set of threads to sleep until woken up. The
API allows either one or all threads to be woken up. If a program only
wakes one thread, the operating system will decide which thread to wake
up. Threads don’t wake threads other directly like by id. Instead, a
thread ‘signal’s the condition variable, which then will wake up one (or
all) threads that are sleeping inside the condition variable.</p>
<p>Condition variables are also used with a mutex and with a loop, so when
woken up they have to check a condition in a critical section. If a
thread needs to be woken up outside of a critical section, there are
other ways to do this in POSIX. Threads sleeping inside a condition
variable are woken up by calling <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_broadcast.3p.html" class="fancy-link">pthread_cond_broadcast</a></code> (wake up all)
or <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code> (wake up one). Note despite the function name,
this has nothing to do with POSIX <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/signal.3p.html" class="fancy-link">signal</a></code>s!</p>
<p>Occasionally, a waiting thread may appear to wake up for no reason. This
is called a <em>spurious wakeup</em>. If you read the hardware implementation
of a mutex section, this is similar to the atomic failure of the same
name.</p>
<p>Why do spurious wakeups happen? For performance. On multi-CPU systems,
it is possible that a race condition could cause a wake-up (signal)
request to be unnoticed. The kernel may not detect this lost wake-up
call but can detect when it might occur. To avoid the potentially lost
signal, the thread is woken up so that the program code can test the
condition again. If you want to know why, check out the appendix.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="thread-safe-data-structures" class="title-text">Thread-Safe Data Structures<a class="anchor title-text" href="#thread-safe-data-structures"> #</a>
</h2></div>











































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Naturally, we want our data structures to be thread-safe as well! We
can use mutexes and synchronization primitives to make that happen.
First a few definitions. Atomicity is when an operation is thread-safe.
We have atomic instructions in hardware by providing the lock prefix</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock ...
</code></pre></div></div>
<p>But Atomicity also applies to higher orders of operations. We say a data
structure operation is atomic if it happens all at once and successfully
or not at all.</p>
<p>As such, we can use synchronization primitives to make our data
structures thread-safe. For the most part, we will be using mutexes
because they carry more semantic meaning than a binary semaphore. Note,
this is an introduction. Writing high-performance thread-safe data
structures requires its own book! Take for example the following
thread-unsafe stack.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A simple fixed-sized stack (version 1)</span>
<span class="cp">#define STACK_SIZE 20
</span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 1 of the stack is thread-unsafe because if two threads call push
or pop at the same time then the results or the stack can be
inconsistent. For example, imagine if two threads call pop at the same
time then both threads may read the same value, both may read the
original count value.</p>
<p>To turn this into a thread-safe data structure we need to identify the
<em>critical sections</em> of our code, meaning we need to ask which section(s)
of the code must only have one thread at a time. In the above example
the <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">pop</code>, and <code class="language-plaintext highlighter-rouge">is_empty</code> functions access the same memory and
all critical sections for the stack. While <code class="language-plaintext highlighter-rouge">push</code> (and <code class="language-plaintext highlighter-rouge">pop</code>) is
executing, the data structure is an inconsistent state, for example the
count may not have been written to, so it may still contain the original
value. By wrapping these methods with a mutex we can ensure that only
one thread at a time can update (or read) the stack. A candidate
‘solution’ is shown below. Is it correct? If not, how will it fail?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attempt at a thread-safe stack (version 2)</span>
<span class="cp">#define STACK_SIZE 20
</span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>

<span class="n">pthread_mutex_t</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 2 contains at least one error. Take a moment to see if you can
the error(s) and work out the consequence(s).</p>
<p>If three threads called <code class="language-plaintext highlighter-rouge">push()</code> at the same time, the lock <code class="language-plaintext highlighter-rouge">m1</code> ensures
that only one thread at time manipulates the stack on push or is_empty
– Two threads will need to wait until the first thread completes A
similar argument applies to concurrent calls to <code class="language-plaintext highlighter-rouge">pop</code>. However, Version
2 does not prevent push and pop from running at the same time because
<code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> use two different mutex locks. The fix is simple in
this case - use the same mutex lock for both the push and pop functions.</p>
<p>The code has a second error. <code class="language-plaintext highlighter-rouge">is_empty</code> returns after the comparison and
leaves the mutex unlocked. However, the error would not be spotted
immediately. For example, suppose one thread calls <code class="language-plaintext highlighter-rouge">is_empty</code> and a
second thread later calls <code class="language-plaintext highlighter-rouge">push</code>. This thread would mysteriously stop.
Using debugger, you can discover that the thread is stuck at the lock()
method inside the <code class="language-plaintext highlighter-rouge">push</code> method because the lock was never unlocked by
the earlier <code class="language-plaintext highlighter-rouge">is_empty</code> call. Thus an oversight in one thread led to
problems much later in time in an arbitrary other thread. Let’s try to
rectify these problems</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An attempt at a thread-safe stack (version 3)</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Version 3 is thread-safe. We have ensured mutual exclusion for all of
the critical sections. There are a few things to note.</p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">is_empty</code> is thread-safe but its result may already be out-of-date.
The stack may no longer be empty by the time the thread gets the
result! This is usually why in thread-safe data structures,
functions that return sizes are removed or deprecated.</p>
  </li>
  <li>
    <p>There is no protection against underflow (popping on an empty stack)
or overflow (pushing onto an already-full stack)</p>
  </li>
</ul>
<p>The last point can be fixed using counting semaphores. The
implementation assumes a single stack. A more general-purpose version
might include the mutex as part of the memory structure and use
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_init.3p.html" class="fancy-link">pthread_mutex_init</a></code> to initialize the mutex. For example,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Support for multiple stacks (each one has a mutex)</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">stack</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">double</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stack_t</span><span class="p">;</span>

<span class="n">stack_t</span><span class="o">*</span> <span class="nf">stack_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">stack_t</span><span class="p">));</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">values</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">);</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">stack_destroy</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">);</span>
  <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Warning no underflow or overflow checks!</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">s1</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">(</span><span class="mi">10</span> <span class="cm">/* Max capacity*/</span><span class="p">);</span>
  <span class="n">stack_t</span> <span class="o">*</span><span class="n">s2</span> <span class="o">=</span> <span class="n">stack_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">push</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">141</span><span class="p">);</span>
  <span class="n">push</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">pop</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
  <span class="n">stack_destroy</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
  <span class="n">stack_destroy</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Before we fix the problems with semaphores. How would we fix the
problems with condition variables? Try it out before you look at the
code in the previous section. We need to wait in push and pop if our
stack is full or empty respectively. Attempted solution:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume cv is a condition variable</span>
<span class="c1">// correctly initialized</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Does the following solution work? Take a second before looking at the
answer to spot the errors.</p>
<p>So did you catch all of them?</p>
<ol>
  <li>
    <p>The first one is a simple one. In push, our check should be against
the total capacity, not zero.</p>
  </li>
  <li>
    <p>We only have if statement checks. wait() could spuriously wake up</p>
  </li>
  <li>
    <p>We never signal any of the threads! Threads could get stuck waiting
indefinitely.</p>
  </li>
</ol>
<p>Let’s fix those errors Does this solution work?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)];</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This solution doesn’t work either! The problem is with the signal. Can
you see why? What would you do to fix it?</p>
<p>Now, how would we use counting semaphores to prevent over and underflow?
Let’s discuss it in the next section.</p>
<h3 id="using-semaphores" class="title-text">Using Semaphores</h3>
<p>Let’s use a counting semaphore to keep track of how many spaces remain
and another semaphore to track the number of items in the stack. We will
call these two semaphores <code class="language-plaintext highlighter-rouge">sremain</code> and <code class="language-plaintext highlighter-rouge">sitems</code>. Remember <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code>
will wait if the semaphore’s count has been decremented to zero (by
another thread calling sem_post).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #1</span>

<span class="n">sem_t</span> <span class="n">sitems</span><span class="p">;</span>
<span class="n">sem_t</span> <span class="n">sremain</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">stack_init</span><span class="p">(){</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="p">...</span>

  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Wait until there's at least one space</span>
    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
    <span class="p">...</span>
  <span class="p">}</span>
</code></pre></div></div>
<p>Sketch #2 has implemented the <code class="language-plaintext highlighter-rouge">post</code> too early. Another thread waiting
in push can erroneously attempt to write into a full stack. Similarly, a
thread waiting in the pop() is allowed to continue too early.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #2 (Error!)</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span> <span class="c1">// error! wakes up pushing() thread too early</span>
  <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span> <span class="c1">// error! wakes up a popping() thread too early</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Sketch 3 implements the correct semaphore logic, but can you spot the
error?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sketch #3 (Error!)</span>
<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Sketch 3 correctly enforces buffer full and buffer empty conditions
using semaphores. However, there is no <em>mutual exclusion</em>. Two threads
can be in the <em>critical section</em> at the same time, which would corrupt
the data structure or least lead to data loss. The fix is to wrap a
mutex around the critical
section:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Simple single stack - see the above example on how to convert this into multiple stacks.</span>
<span class="c1">// Also a robust POSIX implementation would check for EINTR and error codes of sem_wait.</span>

<span class="c1">// PTHREAD_MUTEX_INITIALIZER for statics (use pthread_mutex_init() for stack/heap memory)</span>
<span class="cp">#define SPACES 10
</span><span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">values</span><span class="p">[</span><span class="n">SPACES</span><span class="p">];</span>
<span class="n">sem_t</span> <span class="n">sitems</span><span class="p">,</span> <span class="n">sremain</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremains</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SPACES</span><span class="p">);</span> <span class="c1">// 10 spaces</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one item</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// CRITICAL SECTION</span>
  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span> <span class="c1">// Hey world, there's at least one space</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Wait until there's at least one space</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="c1">// CRITICAL SECTION</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span> <span class="c1">// Hey world, there's at least one item</span>
<span class="p">}</span>
<span class="c1">// Note a robust solution will need to check sem_wait's result for EINTR (more about this later)</span>
</code></pre></div></div>
<p>What happens when we start inverting the lock and wait orders?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">v</span><span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">--</span><span class="n">count</span><span class="p">];</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sremain</span><span class="p">);</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">values</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sitems</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Rather than giving you the answer, we’ll let you think about this. Is
this a permissible way to lock and unlock? Is there a series of
operations that could cause a race condition? How about deadlock? If
there is, provide it. If there isn’t, provide a short justification
proof of why that won’t happen.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="software-solutions-to-the-critical-section" class="title-text">Software Solutions to the Critical Section<a class="anchor title-text" href="#software-solutions-to-the-critical-section"> #</a>
</h2></div>

































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>As already discussed, there are critical parts of our code that can only
be executed by one thread at a time. We describe this requirement as
‘mutual exclusion’. Only one thread (or process) may have access to
the shared resource. In multi-threaded programs, we can wrap a critical
section with mutex lock and unlock
calls:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">()</span> <span class="c1">// one thread allowed at a time! (others will have to wait here)</span>
<span class="c1">// ... Do Critical Section stuff here!</span>
<span class="n">pthread_mutex_unlock</span><span class="p">()</span> <span class="c1">// let other waiting threads continue</span>
</code></pre></div></div>
<p>How would we implement these lock and unlock calls? Can we create a pure
software algorithm that assures mutual exclusion? Here is our attempt
from earlier.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">p_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="p">;</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">p_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>As we touched on earlier, this implementation <em>does not satisfy Mutual
Exclusion</em> even considering that threads can unlock other threads locks.
Let’s take a close look at this ‘implementation’ from two threads
running around the same time.</p>
<p>To simplify the discussion, we consider only two threads. Note these
arguments work for threads and processes and the classic CS literature
discusses these problems in terms of two processes that need exclusive
access to a critical section or shared resource. Raising a flag
represents a thread/process’s intention to enter the critical section.</p>
<p>There are three main desirable properties that we desire in a solution
to the critical section problem.</p>
<ol>
  <li>
    <p>Mutual Exclusion. The thread/process gets exclusive access. Others
must wait until it exits the critical section.</p>
  </li>
  <li>
    <p>Bounded Wait. A thread/process cannot get superseded by another
thread infinite amounts of time.</p>
  </li>
  <li>
    <p>Progress. If no thread/process is inside the critical section, the
thread/process should be able to proceed without having to wait.</p>
  </li>
</ol>
<p>With these ideas in mind, let’s examine another candidate solution that
uses a turn-based flag only if two threads both required access at the
same time.</p>
<h3 id="naive-solutions" class="title-text">Naive Solutions</h3>
<p>Remember that the pseudo-code outlined below is part of a larger
program. The thread or process will typically need to enter the critical
section many times during the lifetime of the process. So, imagine each
example as wrapped inside a loop where for a random amount of time the
thread or process is working on something else.</p>
<p>Is there anything wrong with the candidate solution described below?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #1
wait until your flag is lowered
raise my flag
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>Answer: Candidate solution #1 also suffers from a race condition
because both threads/processes could read each other’s flag value as
lowered and continue.</p>
<p>This suggests we should raise the flag <em>before</em> checking the other
thread’s flag, which is candidate solution #2 below.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #2
raise my flag
wait until your flag is lowered
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>Candidate #2 satisfies mutual exclusion. It is impossible for two
threads to be inside the critical section at the same time. However,
this code suffers from deadlock! Suppose two threads wish to enter the
critical section at the same time.</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Time</th>
      <th style="text-align: center">Thread 1</th>
      <th style="text-align: center">Thread 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: center">Raise Flag</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Raise Flag</td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: center">Wait</td>
      <td style="text-align: center">Wait</td>
    </tr>
  </tbody>
</table>
<p>Candidate Solution #2 Analysis</p>
<p>Both processes are now waiting for the other one to lower their flags.
Neither one will enter the critical section as both are now stuck
forever! This suggests we should use a turn-based variable to try to
resolve who should proceed.</p>
<h3 id="turn-based-solutions" class="title-text">Turn-based solutions</h3>
<p>The following candidate solution #3 uses a turn-based variable to
politely allow one thread and then the other to continue</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #3
wait until my turn is myid
// Do Critical Section stuff
turn = yourid
</code></pre></div></div>
<p>Candidate #3 satisfies mutual exclusion. Each thread or process gets
exclusive access to the Critical Section. However, both
threads/processes must take a strict turn-based approach to use the
critical section. They are forced into an alternating critical section
access pattern. If thread 1 wishes to read a hash table every
millisecond, but another thread writes to a hash table every second,
then the reading thread would have to wait another 999ms before being
able to read from the hash table again. This ‘solution’ is ineffective
because our threads should be able to make progress and enter the
critical section if no other thread is currently in the critical
section.</p>
<h3 id="turn-and-flag-solutions" class="title-text">Turn and Flag solutions</h3>
<p>Is the following a correct solution to CSP?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\\ Candidate #4
raise my flag
if your flag is raised, wait until my turn
// Do Critical Section stuff
turn = yourid
lower my flag
</code></pre></div></div>
<p>Analyzing these solutions is tricky. Even peer-reviewed papers on this
specific subject contain incorrect solutions
(<span class="citeproc-not-found" data-reference-id="Hyman:1966:CPC:365153.365167"><strong>???</strong></span>)!
At first glance, it appears to satisfy Mutual Exclusion, Bounded Wait
and Progress The turn-based flag is only used in the event of a tie, so
Progress and Bounded Wait is allowed and mutual exclusion appears to be
satisfied. Perhaps you can find a counter-example?</p>
<p>Candidate #4 fails because a thread does not wait until the other
thread lowers its flag. After some thought or inspiration, the following
scenario can be created to demonstrate how Mutual Exclusion is not
satisfied.</p>
<p>Imagine the first thread runs this code twice. The turn flag now points
to the second thread. While the first thread is still inside the
Critical Section, the second thread arrives. The second thread can
immediately continue into the Critical
Section!</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: left">Time</th>
      <th style="text-align: left">Turn</th>
      <th style="text-align: left">Thread # 1</th>
      <th style="text-align: left">Thread # 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Raise my flag</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">If your flag is raised, wait until my turn</td>
      <td style="text-align: left">Raise my flag</td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">// Do Critical Section Stuff</td>
      <td style="text-align: left">If your flag is raised, wait until my turn (TRUE!)</td>
    </tr>
    <tr>
      <td style="text-align: left">4</td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">// Do Critical Section Stuff</td>
      <td style="text-align: left">Do Critical Section Stuff - OOPS</td>
    </tr>
  </tbody>
</table>
<p>Candidate Solution #4</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="working-solutions" class="title-text">Working Solutions<a class="anchor title-text" href="#working-solutions"> #</a>
</h2></div>





















<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The first solution to the problem was Dekker’s Solution. Dekker’s
Algorithm (1962) was the first provably correct solution. Though, it was
in an unpublished paper, so it was not discovered until later (Dekker
and Dijkstra
<a href="#ref-dekker_dijkstra_1965" class="fancy-link wiki-link">#ref-dekker_dijkstra_1965</a>) (this
is an English transcribed version released in 1965). A version of the
algorithm is below.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raise my flag
while (your flag is raised) :
   if it is your turn to win :
     lower my flag
     wait while your turn
     raise my flag
// Do Critical Section stuff
set your turn to win
lower my flag
</code></pre></div></div>
<p>Notice how the process’s flag is always raised during the critical
section no matter if the loop is iterated zero, once or more times.
Further, the flag can be interpreted as an immediate intent to enter the
critical section. Only if the other process has also raised the flag
will one process defer, lower their intent flag and wait. Let’s check
the conditions.</p>
<ol>
  <li>
    <p>Mutual Exclusion. Let’s try to sketch a simple proof. The loop
invariant is that at the start of checking the condition, your flag
has to be raised – this is by exhaustion. Since the only way that a
thread can leave the loop is by having the condition be false, the
flag must be raised for the entirety of the critical section. Since
the loop prevents a thread from exiting while the other thread’s
flag is raised and a thread has its flag raised in the critical
section, the other thread can’t enter the critical section at the
same time.</p>
  </li>
  <li>
    <p>Bounded Wait. Assuming that the critical section ends in finite
time, a thread once it has left the critical section cannot then get
the critical section back. The reason being is the turn variable is
set to the other thread, meaning that that thread now has priority.
That means a thread cannot be superseded infinitely by another
thread.</p>
  </li>
  <li>
    <p>Progress. If the other thread isn’t in the critical section, it will
simply continue with a simple check. We didn’t make any statement
about if threads are randomly stopped by the system scheduler. This
is an idealized scenario where threads will keep executing
instructions.</p>
  </li>
</ol>
<h3 id="petersons-solution" class="title-text">Peterson’s Solution</h3>
<p>Peterson published his novel and surprisingly simple solution in 1981
(Peterson
<a href="#ref-Peterson1981MythsAT" class="fancy-link wiki-link">#ref-Peterson1981MythsAT</a>). A
version of his algorithm is shown below that uses a shared variable
<code class="language-plaintext highlighter-rouge">turn</code>.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Candidate #5
raise my flag
turn = other_thread_id
while (your flag is up and turn is other_thread_id)
    loop
// Do Critical Section stuff
lower my flag
</code></pre></div></div>
<p>This solution satisfies Mutual Exclusion, Bounded Wait and Progress. If
thread #2 has set turn to 2 and is currently inside the critical
section. Thread #1 arrives, <em>sets the turn back to 1</em> and now waits
until thread 2 lowers the flag.</p>
<ol>
  <li>
    <p>Mutual Exclusion. Let’s try to sketch a simple proof again. A thread
doesn’t get into the critical section until the turn variable is
yours or the other thread’s flag isn’t up. If the other thread’s
flag isn’t up, it isn’t trying to enter the critical section. That
is the first action the thread does and the last action the thread
undoes. If the turn variable is set to this thread, that means that
the other thread has given the control to this thread. Since my flag
is raised and the turn variable is set, the other thread has to wait
in the loop until the current thread is done.</p>
  </li>
  <li>
    <p>Bounded Wait. After one thread lowers, a thread waiting in the while
loop will leave because the first condition is broken. This means
that threads cannot win all the time.</p>
  </li>
  <li>
    <p>Progress. If no other thread is contesting, other thread’s flags are
not up. That means that a thread can go past the while loop and do
critical section items.</p>
  </li>
</ol>
<p>Unfortunately, we can’t implement a software mutex in the same way today
because of out of order instructions. Check the appendix for a solution
to the problem.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="implementing-counting-semaphore" class="title-text">Implementing Counting Semaphore<a class="anchor title-text" href="#implementing-counting-semaphore"> #</a>
</h2></div>





























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Now that we have a solution to the critical section problem, We can
reasonably implement a mutex. How would we implement other
synchronization primitives? Let’s start with a semaphore. To implement a
semaphore with efficient CPU usage, we will say that we have implemented
a condition variable. Implementing an O(1) space condition variable
using only a mutex is not trivial, or at least an O(1) heap condition
variable is not trivial. We don’t want to call malloc while implementing
a primitive, or we may deadlock!</p>
<ul>
  <li>
    <p>We can implement a counting semaphore using condition variables.</p>
  </li>
  <li>
    <p>Each semaphore needs a count, a condition variable and a mutex</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sem_t</span> <span class="p">{</span>
  <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">pthread_condition_t</span> <span class="n">cv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sem_t</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>
<p>Implement <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_init.3p.html" class="fancy-link">sem_init</a></code> to initialize the mutex and condition variable</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pshared</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">ENOSYS</span> <span class="cm">/* 'Not implemented'*/</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our implementation of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> needs to increment the count. We will
also wake up any threads sleeping inside the condition variable. Notice
we lock and unlock the mutex so only one thread can be inside the
critical section at a time.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
  <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
  <span class="cm">/* A woken thread must acquire the lock, so it will also have to wait until we call unlock*/</span>

  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our implementation of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code> may need to sleep if the semaphore’s
count is zero. Just like <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code>, we wrap the critical section using
the lock, so only one thread can be executing our code at a time. Notice
if the thread does need to wait then the mutex will be unlocked,
allowing another thread to enter <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> and awaken us from our
sleep!</p>
<p>Also notice that even if a thread is woken up before it returns from
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_wait.3p.html" class="fancy-link">pthread_cond_wait</a></code>, it must re-acquire the lock, so it will have to
wait until sem_post finishes.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span> <span class="cm">/*unlock mutex, wait, relock mutex*/</span>
  <span class="p">}</span>
  <span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>That is a complete implementation of a counting semaphore Notice that we
are calling <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> every single time. In practice, this means
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> would unnecessary call <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code> even if there
are no waiting threads. A more efficient implementation would only call
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code> when necessary
i.e.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Did we increment from zero to one- time to signal a thread sleeping inside sem_post */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* Wake up one waiting thread!*/</span>
<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cv</span><span class="p">);</span>
</code></pre></div></div>
<h3 id="other-semaphore-considerations" class="title-text">Other semaphore considerations</h3>
<ul>
  <li>
    <p>A production semaphore implementation may include a queue to ensure
fairness and priority. Meaning, we wake up the highest-priority
and/or longest sleeping thread.</p>
  </li>
  <li>
    <p>An advanced use of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_init.3p.html" class="fancy-link">sem_init</a></code> allows semaphores to be shared across
processes. Our implementation only works for threads inside the same
process. We could fix this by setting the condition variable and
mutex attributes.</p>
  </li>
</ul>
<p>Implementing a condition variable with a mutex is complex, so we’ve left
that in the appendix.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="barriers" class="title-text">Barriers<a class="anchor title-text" href="#barriers"> #</a>
</h2></div>























































































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Suppose we wanted to perform a multi-threaded calculation that has two
stages, but we don’t want to advance to the second stage until the first
stage is completed. We could use a synchronization method called a
<strong>barrier</strong>. When a thread reaches a barrier, it will wait at the
barrier until all the threads reach the barrier, and then they’ll all
proceed together.</p>
<p>Think of it like being out for a hike with some friends. You make a
mental note of how many friends you have and agree to wait for each
other at the top of each hill. Say you’re the first one to reach the top
of the first hill. You’ll wait there at the top for your friends. One by
one, they’ll arrive at the top, but nobody will continue until the last
person in your group arrives. Once they do, you’ll all proceed.</p>
<p>Pthreads has a function <code class="language-plaintext highlighter-rouge">pthread_barrier_wait()</code> that implements this.
You’ll need to declare a <code class="language-plaintext highlighter-rouge">pthread_barrier_t</code> variable and initialize it
with <code class="language-plaintext highlighter-rouge">pthread_barrier_init()</code>. <code class="language-plaintext highlighter-rouge">pthread_barrier_init()</code> takes the number
of threads that will be participating in the barrier as an argument.
Here is a sample program using barriers.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>
<span class="cp">#define THREAD_COUNT 4
</span>
<span class="n">pthread_barrier_t</span> <span class="n">mybarrier</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">threadFn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">id_ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">thread_id</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">id_ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">wait_sec</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: Wait for %d seconds.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">,</span> <span class="n">wait_sec</span><span class="p">);</span>
  <span class="n">sleep</span><span class="p">(</span><span class="n">wait_sec</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: I'm ready...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>

  <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"thread %d: going!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">thread_id</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">pthread_t</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">short_ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>

  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
  <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">THREAD_COUNT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">short_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadFn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">short_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"main() is ready.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"main() is going!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">pthread_barrier_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mybarrier</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now let’s implement our own barrier and use it to keep all the threads
in sync in a large calculation. Here is our thought process,</p>
<ol>
  <li>
    <p>Threads do first calculation (use and change values in data)</p>
  </li>
  <li>
    <p>Barrier! Wait for all threads to finish first calculation before
continuing</p>
  </li>
  <li>
    <p>Threads do second calculation (use and change values in data)</p>
  </li>
</ol>
<p>The thread function has four main parts-</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// double data[256][8192]</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">calc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Do my part of the first calculation */</span>
  <span class="cm">/* Is this the last thread to finish? If so wake up all the other threads! */</span>
  <span class="cm">/* Otherwise wait until the other threads have finished part one */</span>
  <span class="cm">/* Do my part of the second calculation */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our main thread will create the 16 threads, and we will divide each
calculation into 16 separate pieces. Each thread will be given a unique
value (0,1,2,..15), so it can work on its own block. Since a (void*)
type can hold small integers, we will pass the value of <code class="language-plaintext highlighter-rouge">i</code> by casting
it to a void pointer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N (16)
</span><span class="kt">double</span> <span class="n">data</span><span class="p">[</span><span class="mi">256</span><span class="p">][</span><span class="mi">8192</span><span class="p">]</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">ids</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">calc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note, we will never dereference this pointer value as an actual memory
location.</p>
<p>We will cast it straight back to an integer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">calc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Thread 0 will work on rows 0..15, thread 1 on rows 16..31</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">N</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">8192</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* do calc #1 */</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>After calculation 1 completes, we need to wait for the slower threads
unless we are the last thread! So, keep track of the number of threads
that have arrived at our barrier ‘checkpoint’.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Global:</span>
<span class="kt">int</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>

<span class="c1">// After calc #1 code:</span>
<span class="n">remain</span><span class="o">--</span><span class="p">;</span> <span class="c1">// We finished</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*I'm last!  -  Time for everyone to wake up! */</span> <span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* spin spin spin*/</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, the code has a few flaws. One is two threads might try to
decrement <code class="language-plaintext highlighter-rouge">remain</code>. The other is the loop is a busy loop. We can do
better! Let’s use a condition variable and then we will use a
broadcast/signal functions to wake up the sleeping threads.</p>
<p>A reminder, a condition variable is similar to a house! Threads go
there to sleep (<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_wait.3p.html" class="fancy-link">pthread_cond_wait</a></code>). A thread can choose to wake up one
thread (<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code>) or all of them
(<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_broadcast.3p.html" class="fancy-link">pthread_cond_broadcast</a></code>). If there are no threads currently waiting
then these two calls have no effect.</p>
<p>A condition variable version is usually similar to a busy loop incorrect
solution - as we will show next. First, let’s add a mutex and condition
global variables and don’t forget to initialize them in <code class="language-plaintext highlighter-rouge">main</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global variables</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cv</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p>We will use the mutex to ensure that only one thread modifies <code class="language-plaintext highlighter-rouge">remain</code>
at a time. The last arriving thread needs to wake up <em>all</em> sleeping
threads - so we will use <code class="language-plaintext highlighter-rouge">pthread_cond_broadcast(&amp;cv)</code> not
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="n">remain</span><span class="o">--</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</code></pre></div></div>
<p>When a thread enters <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_wait.3p.html" class="fancy-link">pthread_cond_wait</a></code>, it releases the mutex and
sleeps. After, the thread will be woken up. Once we bring a thread back
from its sleep, before returning it must wait until it can lock the
mutex. Notice that even if a sleeping thread wakes up early, it will
check the while loop condition and re-enter wait if necessary.</p>
<p><strong>The above barrier is not reusable</strong>. Meaning that if we stick it into
any old calculation loop there is a good chance that the code will
encounter a condition where the barrier either deadlocks or thread races
ahead one iteration faster. Why is that? Because of the ambitious
thread.</p>
<p>We will assume that one thread is much faster than all the other
threads. With the barrier API, this thread should be waiting, but it may
not be. To make it concrete, let’s look at this code</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">barrier_wait</span><span class="p">(</span><span class="n">barrier</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
  <span class="c1">// If it is 0 before decrement, we should be on</span>
  <span class="c1">// another iteration right?</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">=</span> <span class="n">NUM_THREADS</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">remain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Some calc</span>
  <span class="n">barrier_wait</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What happens if a thread becomes ambitious. Well</p>
<ol>
  <li>
    <p>Many other threads wait on the condition variable</p>
  </li>
  <li>
    <p>The last thread broadcasts.</p>
  </li>
  <li>
    <p>A single thread leaves the while loop.</p>
  </li>
  <li>
    <p>This single thread performs its calculation before any other threads
<em>even wake up</em></p>
  </li>
  <li>
    <p>Reset the number of remaining threads and goes back to sleep.</p>
  </li>
</ol>
<p>All the other threads who should’ve woken up never do and our
implementation deadlocks. How would you go about solving this? Hint: If
multiple threads call <code class="language-plaintext highlighter-rouge">barrier_wait</code> in a loop then one can guarantee
that they are on the same iteration.</p>
<h3 id="reader-writer-problem" class="title-text">Reader Writer Problem</h3>
<p>Imagine you had a key-value map data structure that is used by many
threads. Multiple threads should be able to look up (read) values at the
same time provided the data structure is not being written to. The
writers are not so gregarious. To avoid data corruption, only one thread
at a time may modify (<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>) the data structure and no readers may be
reading at that time.</p>
<p>This is an example of the <em>Reader Writer Problem</em>. Namely, how can we
efficiently synchronize multiple readers and writers such that multiple
readers can read together, but a writer gets exclusive access?</p>
<p>An incorrect attempt is shown below (“lock” is a shorthand for
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_lock.3p.html" class="fancy-link">pthread_mutex_lock</a></code>):</p>
<h3 id="attempt-1" class="title-text">Attempt #1</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// do read stuff</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// do write stuff</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At least our first attempt does not suffer from data corruption. Readers
must wait while a writer is writing and vice versa! However, readers
must also wait for other readers. Let’s try another implementation.</p>
<h3 id="attempt-2" class="title-text">Attempt #2:</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">writing</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*spin*/</span><span class="p">}</span>
  <span class="n">reading</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// do read stuff</span>
  <span class="n">reading</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span> <span class="p">{</span><span class="cm">/*spin*/</span><span class="p">}</span>
  <span class="n">writing</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// do write stuff</span>
  <span class="n">writing</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Our second attempt suffers from a race condition. Imagine if two threads
both called <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code> or both called write at the same time.
Both threads would be able to proceed! Secondly, we can have multiple
readers and multiple writers, so let’s keep track of the total number of
readers or writers Which brings us to attempt #3.</p>
<h3 id="attempt-3" class="title-text">Attempt #3</h3>
<p>Remember that <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_wait.3p.html" class="fancy-link">pthread_cond_wait</a></code> performs <em>Three</em> actions. Firstly, it
atomically unlocks the mutex and then sleeps (until it is woken by
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code> or <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_broadcast.3p.html" class="fancy-link">pthread_cond_broadcast</a></code>). Thirdly, the awoken
thread must re-acquire the mutex lock before returning. Thus only one
thread can actually be running inside the critical section defined by
the lock and unlock() methods.</p>
<p>Implementation #3 below ensures that a reader will enter the
<code class="language-plaintext highlighter-rouge">cond_wait</code> if any writers are writing.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* Read here! */</span>

  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>However, only one reader a time can read because candidate #3 did not
unlock the mutex. A better version unlocks before reading.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="cm">/* Read here! */</span>

  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Does this mean that a writer and read could read and write at the same
time? No! First of all, remember cond_wait requires the thread
re-acquire the mutex lock before returning. Thus only one thread can be
executing code inside the critical section (marked with **) at a
time!</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="o">**</span>  <span class="n">reading</span><span class="o">++</span><span class="p">;</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="cm">/* Read here! */</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="o">**</span>  <span class="n">reading</span><span class="o">--</span>
  <span class="o">**</span>  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Writers must wait for everyone. Mutual exclusion is assured by the lock.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="o">**</span>      <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="o">**</span>  <span class="n">writing</span><span class="o">++</span><span class="p">;</span>
  <span class="o">**</span>
  <span class="o">**</span> <span class="cm">/* Write here! */</span>
  <span class="o">**</span>  <span class="n">writing</span><span class="o">--</span><span class="p">;</span>
  <span class="o">**</span>  <span class="n">cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Candidate #3 above also uses <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_cond_signal.3p.html" class="fancy-link">pthread_cond_signal</a></code>. This will only wake
up one thread. If many readers are waiting for the writer to complete,
only one sleeping reader will be awoken from their slumber. The reader
and writer should use <code class="language-plaintext highlighter-rouge">cond_broadcast</code> so that all threads should wake
up and check their while-loop condition.</p>
<h3 id="starving-writers" class="title-text">Starving writers</h3>
<p>Candidate #3 above suffers from starvation. If readers are constantly
arriving then a writer will never be able to proceed (the ‘reading’
count never reduces to zero). This is known as <em>starvation</em> and would be
discovered under heavy loads. Our fix is to implement a bounded-wait for
the writer. If a writer arrives they will still need to wait for
existing readers however future readers must be placed in a “holding
pen” and wait for the writer to finish. The “holding pen” can be
implemented using a variable and a condition variable so that we can
wake up the threads once the writer has finished.</p>
<p>The plan is that when a writer arrives, and before waiting for current
readers to finish, register our intent to write by incrementing a
counter ‘writer’</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">()</span>
  <span class="n">writer</span><span class="o">++</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span>
  <span class="n">unlock</span><span class="p">()</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>And incoming readers will not be allowed to continue while writer is
nonzero. Notice ‘writer’ indicates a writer has arrived, while ‘reading’
and ‘writing’ counters indicate there is an <em>active</em> reader or writer.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">()</span>
  <span class="c1">// readers that arrive *after* the writer arrived will have to wait here!</span>
  <span class="k">while</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="c1">// readers that arrive while there is an active writer</span>
  <span class="c1">// will also wait.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">++</span>
  <span class="n">unlock</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="attempt-4" class="title-text">Attempt #4</h3>
<p>Below is our first working solution to the Reader-Writer problem. Note
if you continue to read about the “Reader Writer problem” then you will
discover that we solved the “Second Reader Writer problem” by giving
writers preferential access to the lock. This solution is not optimal.
However, it satisfies our original problem of N active readers, single
active writer, and avoiding starvation of the writer if there is a
constant stream of readers.</p>
<p>Can you identify any improvements? For example, how would you improve
the code so that we only woke up readers or one
writer?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">writers</span><span class="p">;</span> <span class="c1">// Number writer threads that want to enter the critical section (some or all of these may be blocked)</span>
<span class="kt">int</span> <span class="n">writing</span><span class="p">;</span> <span class="c1">// Number of threads that are actually writing inside the C.S. (can only be zero or one)</span>
<span class="kt">int</span> <span class="n">reading</span><span class="p">;</span> <span class="c1">// Number of threads that are actually reading inside the C.S.</span>
<span class="c1">// if writing !=0 then reading must be zero (and vice versa)</span>

<span class="n">reader</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">writers</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// No need to wait while(writing here) because we can only exit the above loop</span>
  <span class="c1">// when writing is zero</span>
  <span class="n">reading</span><span class="o">++</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>

  <span class="c1">// perform reading here</span>

  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">reading</span><span class="o">--</span>
  <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">writer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writers</span><span class="o">++</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">reading</span> <span class="o">||</span> <span class="n">writing</span><span class="p">)</span>
  <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writing</span><span class="o">++</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="c1">// perform writing here</span>
  <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
  <span class="n">writing</span><span class="o">--</span>
  <span class="n">writers</span><span class="o">--</span>
  <span class="n">cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span>
  <span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="ring-buffer" class="title-text">Ring Buffer<a class="anchor title-text" href="#ring-buffer"> #</a>
</h2></div>























































<!-- end list -->











<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>A ring buffer is a simple, usually fixed-sized, storage mechanism where
contiguous memory is treated as if it is circular, and two index
counters keep track of the current beginning and end of the queue. As
array indexing is not circular, the index counters must wrap around to
zero when moved past the end of the array. As data is added (enqueued)
to the front of the queue or removed (dequeued) from the tail of the
queue, the current items in the buffer form a train that appears to
circle the track</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/synchronization/drawings/ring_buffer.png" alt="Ring Buffer
Visualization"></p>
<p>A simple (single-threaded) implementation is shown below. Note, enqueue
and dequeue do not guard against underflow or overflow. It’s possible to
add an item when the queue is full and possible to remove an item when
the queue is empty. If we added 20 integers (1, 2, 3, …, 20) to the
queue and did not dequeue any items then values, <code class="language-plaintext highlighter-rouge">17,18,19,20</code> would
overwrite the <code class="language-plaintext highlighter-rouge">1,2,3,4</code>. We won’t fix this problem right now, instead of
when we create the multi-threaded version we will ensure enqueue-ing and
dequeue-ing threads are blocked while the ring buffer is full or empty
respectively.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Add one item to the front of the queue*/</span>
  <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">in</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* Advance the index for next time */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Wrap around! */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Remove one item to the end of the queue.*/</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>
  <span class="n">out</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="ring-buffer-gotchas" class="title-text">Ring Buffer Gotchas</h3>
<p>It’s tempting to write the enqueue or dequeue method in the following
compact form.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// N is the capacity of the buffer</span>
<span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This method would appear to work but contains a subtle bug. With more
than four billion enqueue operations, the int value of <code class="language-plaintext highlighter-rouge">in</code> will
overflow and wrap around to 0! Thus, you might end up writing into
<code class="language-plaintext highlighter-rouge">b[0]</code> for example!</p>
<p>A compact form is correct uses bit masking provided N is a power of two.
(16,32,64,…)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</code></pre></div></div>
<p>This buffer does not yet prevent overwrites. For that, we’ll turn to our
multi-threaded attempt that will block a thread until there is space or
there is at least one item to remove.</p>
<h3 id="multithreaded-correctness" class="title-text">Multithreaded Correctness</h3>
<p>The following code is an incorrect implementation. What will happen?
Will <code class="language-plaintext highlighter-rouge">enqueue</code> and/or <code class="language-plaintext highlighter-rouge">dequeue</code> block? Is mutual exclusion satisfied?
Can the buffer underflow? Can the buffer overflow? For clarity,
<code class="language-plaintext highlighter-rouge">pthread_mutex</code> is shortened to <code class="language-plaintext highlighter-rouge">p_m</code> and we assume sem_wait cannot be
interrupted.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 16
</span><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span>
<span class="n">sem_t</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">p_m_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// Hint: Wait while zero. Decrement and return</span>
  <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">s1</span> <span class="p">)</span>

  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

  <span class="c1">// Hint: Increment. Will wake up a waiting thread</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="analysis" class="title-text">Analysis</h3>
<p>Before reading on, see how many mistakes you can find. Then determine
what would happen if threads called the enqueue and dequeue methods.</p>
<ul>
  <li>
    <p>The enqueue method waits and posts on the same semaphore (s1) and
similarly with enqueue and (s2) i.e. we decrement the value and then
immediately increment the value, so by the end of the function the
semaphore value is unchanged!</p>
  </li>
  <li>The initial value of s1 is 16, so the semaphore will never be
reduced to zero - enqueue will not block if the ring buffer is full
    <ul>
      <li>so overflow is possible.</li>
    </ul>
  </li>
  <li>
    <p>The initial value of s2 is zero, so calls to dequeue will always
block and never return!</p>
  </li>
  <li>The order of mutex lock and sem_wait will need to be swapped;
however, this example is so broken that this bug has no effect!</li>
</ul>
<h3 id="another-analysis" class="title-text">Another Analysis</h3>
<p>The following code is an incorrect implementation. What will happen?
Will <code class="language-plaintext highlighter-rouge">enqueue</code> and/or <code class="language-plaintext highlighter-rouge">dequeue</code> block? Is mutual exclusion satisfied?
Can the buffer underflow? Can the buffer overflow? For clarity
<code class="language-plaintext highlighter-rouge">pthread_mutex</code> is shortened to <code class="language-plaintext highlighter-rouge">p_m</code> and we assume sem_wait cannot be
interrupted.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span>
<span class="n">sem_t</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">)</span>
  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Here are a few problems that we hope you’ve found.</p>
<ul>
  <li>
    <p>The initial value of s2 is 0. Thus enqueue will block on the first
call to sem_wait even though the buffer is empty!</p>
  </li>
  <li>
    <p>The initial value of s1 is 16. Thus dequeue will not block on the
first call to sem_wait even though the buffer is empty -
Underflow! The dequeue method will return invalid data.</p>
  </li>
  <li>
    <p>The code does not satisfy Mutual Exclusion. Two threads can modify
<code class="language-plaintext highlighter-rouge">in</code> or <code class="language-plaintext highlighter-rouge">out</code> at the same time! The code appears to use mutex lock.
Unfortunately, the lock was never initialized with
<code class="language-plaintext highlighter-rouge">pthread_mutex_init()</code> or <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code> - so the lock
may not work (<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_lock.3p.html" class="fancy-link">pthread_mutex_lock</a></code> may simply do nothing)</p>
  </li>
</ul>
<h3 id="correct-implementation-of-a-ring-buffer" class="title-text">Correct implementation of a ring buffer</h3>
<p>As the mutex lock is stored in global (static) memory it can be
initialized with <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_INITIALIZER</code>. If we had allocated space
for the mutex on the heap, then we would have used
<code class="language-plaintext highlighter-rouge">pthread_mutex_init(ptr, NULL)</code></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="c1">// N must be 2^i</span>
<span class="cp">#define N (16)
</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">p_m_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="n">sem_t</span> <span class="n">countsem</span><span class="p">,</span> <span class="n">spacesem</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spacesem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The enqueue method is shown below. Make sure to note.</p>
<ol>
  <li>
    <p>The lock is only held during the critical section (access to the
data structure).</p>
  </li>
  <li>
    <p>A complete implementation would need to guard against early returns
from <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code> due to POSIX signals.</p>
  </li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enqueue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="c1">// wait if there is no space left:</span>
  <span class="n">sem_wait</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">spacesem</span> <span class="p">)</span>

  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="n">b</span><span class="p">[</span> <span class="p">(</span><span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// increment the count of the number of items</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">dequeue</code> implementation is shown below. Notice the symmetry of the
synchronization calls to <code class="language-plaintext highlighter-rouge">enqueue</code>. In both cases, the functions first
wait if the count of spaces or count of items is zero.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">dequeue</span><span class="p">(){</span>
  <span class="c1">// Wait if there are no items in the buffer</span>
  <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">countsem</span><span class="p">)</span>

  <span class="n">p_m_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">[(</span><span class="n">out</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
  <span class="n">p_m_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span>

  <span class="c1">// Increment the count of the number of spaces</span>
  <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spacesem</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Food for thought:</p>
<ul>
  <li>
    <p>What would happen if the order of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_unlock.3p.html" class="fancy-link">pthread_mutex_unlock</a></code> and
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_post.3p.html" class="fancy-link">sem_post</a></code> calls were swapped?</p>
  </li>
  <li>
    <p>What would happen if the order of <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sem_wait.3p.html" class="fancy-link">sem_wait</a></code> and
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pthread_mutex_lock.3p.html" class="fancy-link">pthread_mutex_lock</a></code> calls were swapped?</p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="extra-process-synchronization" class="title-text">Extra: Process Synchronization<a class="anchor title-text" href="#extra-process-synchronization"> #</a>
</h2></div>































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>You thought that you were using different processes, so you don’t have
to synchronize? Think again! You may not have race conditions within a
process but what if your process needs to interact with the system
around it? Let’s consider a motivating example</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"my_file.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key1: value1"</span><span class="p">);</span>
    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key2: value2"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>If none of the system calls fail then we should get something that looks
like this given the file was empty to begin with.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key1: value1
key2: value2

key2: value2
key1: value1
</code></pre></div></div>
<h3 id="interruption" class="title-text">Interruption</h3>
<p>But, there is a hidden nuance. Most system calls can be <code class="language-plaintext highlighter-rouge">interrupted</code>
meaning that the operating system can stop an ongoing system call
because it needs to stop the process. So barring <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fork.3p.html" class="fancy-link">fork</a></code> <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/wait.3p.html" class="fancy-link">wait</a></code> <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/open.3p.html" class="fancy-link">open</a></code>
and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/close.3p.html" class="fancy-link">close</a></code> from failing – they typically go to completion – what
happens if <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code> fails? If write fails and no bytes are written, we
can get something like <code class="language-plaintext highlighter-rouge">key1: value1</code> or <code class="language-plaintext highlighter-rouge">key2: value2</code>. This is data
loss which is incorrect but won’t corrupt the file. What happens if
write gets interrupted after a partial write? We get all sorts of
madness. For example,</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key2: key1: value1
</code></pre></div></div>
<h3 id="solution" class="title-text">Solution</h3>
<p>A program can create a mutex before fork-ing - however the child and
parent process will not share virtual memory and each one will have a
mutex independent of the other. Advanced note: There are advanced
options using shared memory that allow a child and parent to share a
mutex if it’s created with the correct options and uses a shared memory
segment. See
<a href="http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes" class="fancy-link wiki-link">http://stackoverflow.com/questions/19172541/procs-fork-and-mutexes</a></p>
<p>So what should we do? We should use a shared mutex! Consider the
following code.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="o">*</span> <span class="n">mutex</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">pthread_mutexattr_t</span> <span class="n">attr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">write_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"my_file.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">bytes_to_write</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="n">bytes_to_write</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">written</span> <span class="o">+=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">written</span><span class="p">,</span> <span class="n">bytes_to_write</span> <span class="o">-</span> <span class="n">written</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">pthread_mutexattr_setpshared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_PROCESS_SHARED</span><span class="p">);</span>
  <span class="n">pmutex</span> <span class="o">=</span> <span class="n">mmap</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">),</span>
  <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_ANON</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="n">pmutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attrmutex</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key1: value1"</span><span class="p">);</span>
    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pmutex</span><span class="p">);</span>
    <span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrmutex</span><span class="p">);</span>
    <span class="n">munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pmutex</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pmutex</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">write_string</span><span class="p">(</span><span class="s">"key2: value2"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>What the code does in main is initialize a process shared mutex using a
piece of <code class="language-plaintext highlighter-rouge">shared</code> memory. You will find out what this call to <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code>
does later – assume for the time being that it creates memory that is
shared between processes. We can initialize a <code class="language-plaintext highlighter-rouge">pthread_mutex_t</code> in that
special piece of memory and use it as normal. To counter <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>
failing, we have put the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code> call inside a while loop that keeps
writing so long as there are bytes left to write. Now if all the other
system calls function, there should be more race conditions.</p>
<p>Most programs try to avoid this problem entirely by writing to separate
files, but it is good to know that there are mutexes across processes,
and they are useful. A program can use all of the primitives that were
mentioned previouslty! Barriers, semaphores, and condition variables
can all be initialized on a shared piece of memory and used in similar
ways to their multithreading counterparts.</p>
<ul>
  <li>
    <p>You don’t have to worry about arbitrary memory addresses becoming
race condition candidates. Only areas that specifically mapped are
in danger.</p>
  </li>
  <li>
    <p>You get the nice isolation of processes so if one process fails the
system can maintain intact.</p>
  </li>
  <li>
    <p>When you have a lot of threads, creating a process might ease the
system load</p>
  </li>
</ul>
<p>There are other ways to synchronize as well, check out goroutines or
higher orders of synchronization in the appendix.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="external-resources" class="title-text">External Resources<a class="anchor title-text" href="#external-resources"> #</a>
</h2></div>





<!-- end list -->



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Guiding questions for the man pages</p>
<ul>
  <li>
    <p>How is a recursive mutex different than a default mutex?</p>
  </li>
  <li>
    <p>How is mutex trylock different than mutex lock?</p>
  </li>
  <li>
    <p>Why would a mutex lock fail? What’s an example?</p>
  </li>
  <li>
    <p>What happens if a thread tries to destroy a locked mutex?</p>
  </li>
  <li>
    <p>Can a thread copy the underlying bytes of a mutex instead of using a
pointer?</p>
  </li>
  <li>
    <p>What is the lifecycle of a
semaphore?</p>
  </li>
</ul>
<ul>
  <li>
    <p><a href="http://linux.die.net/man/3/pthread_mutex_lock" class="fancy-link wiki-link">http://linux.die.net/man/3/pthread_mutex_lock</a></p>
  </li>
  <li>
    <p><a href="http://linux.die.net/man/3/pthread_mutex_init" class="fancy-link wiki-link">http://linux.die.net/man/3/pthread_mutex_init</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_init.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_init.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_wait.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_wait.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_post.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_post.3.html</a></p>
  </li>
  <li>
    <p><a href="http://man7.org/linux/man-pages/man3/sem_destroy.3.html" class="fancy-link wiki-link">http://man7.org/linux/man-pages/man3/sem_destroy.3.html</a></p>
  </li>
</ul>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics"> #</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ul>
  <li>
    <p>Atomic operations</p>
  </li>
  <li>
    <p>Critical Section</p>
  </li>
  <li>
    <p>Producer Consumer Problem</p>
  </li>
  <li>
    <p>Using Condition Variables</p>
  </li>
  <li>
    <p>Using Counting Semaphore</p>
  </li>
  <li>
    <p>Implementing a barrier</p>
  </li>
  <li>
    <p>Implementing a ring buffer</p>
  </li>
  <li>
    <p>Using pthread_mutex</p>
  </li>
  <li>
    <p>Implementing producer consumer</p>
  </li>
  <li>
    <p>Analyzing multi-threaded coded</p>
  </li>
</ul></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions"> #</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<ul>
  <li>
    <p>What is atomic operation?</p>
  </li>
  <li>
    <p>Why will the following not work in parallel code</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">//In the global section</span>
<span class="kt">size_t</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//In pthread function</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>And this will?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c1">//In the global section</span>
<span class="n">atomic_size_t</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//In pthread function</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>What are some downsides to atomic operations? What would be faster:
keeping a local variable or many atomic operations?</p>
  </li>
  <li>
    <p>What is the critical section?</p>
  </li>
  <li>
    <p>Once you have identified a critical section, what is one way of
assuring that only one thread will be in the section at a time?</p>
  </li>
  <li>
    <p>Identify the critical section here</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">linked_list</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">node</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_linked_list</span><span class="p">(</span><span class="n">linked_list</span> <span class="o">*</span><span class="n">ll</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span><span class="p">){</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">packaged</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">){</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">packaged</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">packaged</span><span class="p">;</span>
    <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
    
<span class="kt">void</span><span class="o">*</span> <span class="nf">pop_elem</span><span class="p">(</span><span class="n">linked_list</span> <span class="o">*</span><span class="n">ll</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
  <span class="n">node</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ll</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">index</span><span class="o">--</span><span class="p">){</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">//i points to the element we need to pop, prev before</span>
  <span class="k">if</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">ll</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">;</span>
  <span class="n">destroy_node</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">elem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>How tight can you make the critical section?</p>
  </li>
  <li>
    <p>What is a producer consumer problem? How might the above be a
producer consumer problem be used in the above section? How is a
producer consumer problem related to a reader writer problem?</p>
  </li>
  <li>
    <p>What is a condition variable? Why is there an advantage to using one
over a <code class="language-plaintext highlighter-rouge">while</code> loop?</p>
  </li>
  <li>
    <p>Why is this code dangerous?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">not_ready</span><span class="p">){</span>
  <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>What is a counting semaphore? Give me an analogy to a cookie
jar/pizza box/limited food item.</p>
  </li>
  <li>
    <p>What is a thread barrier?</p>
  </li>
  <li>
    <p>Use a counting semaphore to implement a barrier.</p>
  </li>
  <li>
    <p>Write up a Producer/Consumer queue, How about a producer consumer
stack?</p>
  </li>
  <li>
    <p>Give me an implementation of a reader-writer lock with condition
variables, make a struct with whatever you need, it needs to be able
to support the following functions</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    
    
<span class="p">}</span> <span class="n">rw_lock_t</span><span class="p">;</span>
    
<span class="kt">void</span> <span class="nf">reader_lock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">writer_lock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">reader_unlock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">writer_unlock</span><span class="p">(</span><span class="n">rw_lock_t</span><span class="o">*</span> <span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></div>    </div>

    <p>The only specification is that in between <code class="language-plaintext highlighter-rouge">reader_lock</code> and
<code class="language-plaintext highlighter-rouge">reader_unlock</code>, no writers can write. In between the writer locks,
only one writer may be writing at a time.</p>
  </li>
  <li>
    <p>Write code to implement a producer consumer using ONLY three
counting semaphores. Assume there can be more than one thread
calling enqueue and dequeue. Determine the initial value of each
semaphore.</p>
  </li>
  <li>
    <p>Write code to implement a producer consumer using condition
variables and a mutex. Assume there can be more than one thread
calling enqueue and dequeue.</p>
  </li>
  <li>
    <p>Use CVs to implement add(unsigned int) and subtract(unsigned int)
blocking functions that never allow the global value to be greater
than 100.</p>
  </li>
  <li>
    <p>Use CVs to implement a barrier for 15 threads.</p>
  </li>
  <li>
    <p>What does the following code do?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
    
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Is the following code correct? If it isn’t, could you fix it?</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="n">money</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">deposit</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">money</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">withdraw</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">money</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
  <span class="p">}</span>
    
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
  <span class="n">money</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sketch how to use a binary semaphore as a mutex. Remember in
addition to mutual exclusion, a mutex can only ever be unlocked by
the thread who called it.</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">sem</span><span class="p">;</span>
    
<span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span>
    
<span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>How many of the following statements are true?</p>

    <ul>
      <li>
        <p>There can be multiple active readers</p>
      </li>
      <li>
        <p>There can be multiple active writers</p>
      </li>
      <li>
        <p>When there is an active writer the number of active readers must
be zero</p>
      </li>
      <li>
        <p>If there is an active reader the number of active writers must
be zero</p>
      </li>
      <li>
        <p>A writer must wait until the current active readers have
finished</p>
      </li>
    </ul>
  </li>
</ul>
<div id="refs" class="references">

<div id="ref-dekker_dijkstra_1965">

Dekker, T.J., and Edsgar Dijkstra. 1965. “Over de Sequentialiteit van
Procesbeschrijvingen.” *E.W.Dijkstra Archive: Over de Sequentialiteit
van Procesbeschrijvingen (EWD 35)*. University of Texas Austin.
<a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD00xx/EWD35.html" class="fancy-link wiki-link">http://www.cs.utexas.edu/users/EWD/transcriptions/EWD00xx/EWD35.html</a>.

</div>

<div id="ref-Peterson1981MythsAT">

Peterson, Gary L. 1981. “Myths About the Mutual Exclusion Problem.”
*Inf. Process. Lett.* 12: 115–16.

</div>

</div>
</div></div></div>
</div></div>
</div>
            
            <div class="wrapper">
</div>
          </div>
          <div class="col-md-2 col-sm-1 col-xs-0"></div>
        </div>
        <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Bring in JQuery and Bootstrap -->
<script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" crossorigin="anonymous"></script>
<!-- For table of content -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script src="/js/scroll.js"></script>
<footer class="">

<!-- Add another container at the bottom so there is some space there -->
<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

      </div>
    </div>
  </div>
  <script type="application/javascript">
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_coursebook/Synchronization.md";
  </script>
</body>

</html>