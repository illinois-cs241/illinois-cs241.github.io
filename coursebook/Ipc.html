<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <!-- If for some reason you are using IE, use edge -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- So bootstrap isn't horrible, set the width -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <title>CS 341 · Ipc</title>

  <!-- Reference a CDN so this is properly cached in the browser forever. Unless they clean out the
       Cache this will incur no load time. Ideally we should put a security checksum but that breaks
       Firefox development sometimes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" crossorigin="anonymous">
  <!-- For table of content  -->

  <link rel="stylesheet" href="/css/code-style.css"/>
  <link rel="stylesheet" href="/css/main.css"/>
  <link rel="stylesheet" href="/css/bootstrap-toc.css"/>

  <meta property="og:locale" content="en_US">

  
  <meta property="og:title" content="Ipc" />
  

  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://cs341.cs.illinois.edu" />

  
  <meta property="og:description" content=""Webpage for CS 341: System Programming at the University of Illinois Urbana-Champaign. All documentation and information about the course can be found here."
" />
  

</head>


<body data-spy="scroll" data-target="#overview" data-offset="50">
  <div class="container-fluid">
    <div class="row" style="display: flex; justify-content: stretch;">
      <!-- Always shows a header, even in smaller screens. -->
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <!-- Navigation button as html so we don't have to resize images -->
      <button
        type="button"
        class="navbar-toggle collapsed"
        data-toggle="collapse"
        data-target=".navbar-collapse"
        aria-expanded="false"
        aria-controls="navbar"
      >
        <!-- Hamburger Navigation bar on small -->
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Full title on laptop -->
      <a class="navbar-brand navbar-item normal" href="/">
             <span>CS 341: System Programming</span> 
      </a>

      <!-- Smaller on mobile-->
      <a class="navbar-brand navbar-item small" href="/">
          <span>CS 341</span>
      </a>
    </div>

    <!-- Finally generate what is in the navbar -->
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
        <li class="navbar-item">
          <a href="/assignments.html">Assignments</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/quiz_topics.html">Quizzes</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/grades.html">Grades</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/schedule.html">Lectures</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/syllabus.html">Syllabus</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/staff.html">Staff</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/resources.html">Resources</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
            <li class="navbar-subitem">
              <a href="/peer_tutoring.html">Peer Tutoring</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/coursebook/index.html">Coursebook</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="">Lecture Materials</a>
            </li>
            
            <li class="navbar-subitem">
              <a href="/tutorials/development">Linux Virtual Machine</a>
            </li>
            
          </ul>
        </li>
        
        <li class="navbar-item">
          <a href="/honors.html">Honors</a>
          <!-- Generate sublinks-->
          <ul class="nav navbar-nav subitem-container">
            
          </ul>
        </li>
        
      </ul>
    </div>
  </div>
  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Roboto"
    rel="stylesheet"
  />
</nav>

      <div class="row">
        <div class="col-sm-3 col-xs-12 hidden-xs" style="min-height: 100%">
          <nav id="overview" data-toggle="toc" class="sticky-top"></nav>
        </div>
        <div class="col-sm-9 col-xs-12">
          <div class="title">
            
            
            
            <h1>
              Ipc
            </h1>
          </div>
          <div class="content col-sm-11 .col-sm-offset-1">
            
          </div>
          <div class="hidden-sm hidden-md hidden-lg">
            
          </div>
          <div id="content">
            


            <div class="wrapper">
<ul>
  <li>
<a href="#virtual-memory-and-interprocess-communication" class="fancy-link wiki-link">Virtual Memory and Interprocess
Communication</a>
    <ul>
      <li>
<a href="#translating-addresses" class="fancy-link wiki-link">Translating Addresses</a>
        <ul>
          <li><a href="#terminology" class="fancy-link wiki-link">Terminology</a></li>
          <li><a href="#multi-level-page-tables" class="fancy-link wiki-link">Multi-level page tables</a></li>
          <li><a href="#page-table-disadvantages" class="fancy-link wiki-link">Page Table Disadvantages</a></li>
          <li><a href="#mmu-algorithm" class="fancy-link wiki-link">MMU Algorithm</a></li>
          <li><a href="#frames-and-page-protections" class="fancy-link wiki-link">Frames and Page Protections</a></li>
          <li><a href="#page-faults" class="fancy-link wiki-link">Page Faults</a></li>
          <li><a href="#link-back-to-ipc" class="fancy-link wiki-link">Link Back to IPC</a></li>
        </ul>
      </li>
      <li>
<a href="#mmap" class="fancy-link wiki-link">mmap</a>
        <ul>
          <li><a href="#mmap-definitions" class="fancy-link wiki-link">mmap Definitions</a></li>
          <li><a href="#annotated-mmap-walkthrough" class="fancy-link wiki-link">Annotated mmap Walkthrough</a></li>
          <li><a href="#mmap-communication" class="fancy-link wiki-link">MMAP Communication</a></li>
        </ul>
      </li>
      <li>
<a href="#pipes" class="fancy-link wiki-link">Pipes</a>
        <ul>
          <li><a href="#pipe-gotchas" class="fancy-link wiki-link">Pipe Gotchas</a></li>
          <li><a href="#other-pipe-facts" class="fancy-link wiki-link">Other pipe facts</a></li>
          <li><a href="#pipes-and-dup" class="fancy-link wiki-link">Pipes and Dup</a></li>
          <li><a href="#pipe-conveniences" class="fancy-link wiki-link">Pipe Conveniences</a></li>
        </ul>
      </li>
      <li>
<a href="#named-pipes" class="fancy-link wiki-link">Named Pipes</a>
        <ul>
          <li><a href="#hanging-named-pipes" class="fancy-link wiki-link">Hanging Named Pipes</a></li>
          <li><a href="#race-condition-with-named-pipes" class="fancy-link wiki-link">Race condition with named
pipes</a></li>
        </ul>
      </li>
      <li>
<a href="#files" class="fancy-link wiki-link">Files</a>
        <ul>
          <li><a href="#determining-file-length" class="fancy-link wiki-link">Determining File Length</a></li>
          <li><a href="#use-stat-instead" class="fancy-link wiki-link">Use stat instead</a></li>
          <li><a href="#gotchas-with-files" class="fancy-link wiki-link">Gotchas with files</a></li>
        </ul>
      </li>
      <li><a href="#ipc-alternatives" class="fancy-link wiki-link">IPC Alternatives</a></li>
      <li><a href="#topics" class="fancy-link wiki-link">Topics</a></li>
      <li><a href="#questions" class="fancy-link wiki-link">Questions</a></li>
    </ul>
  </li>
</ul>

<p><span> </span></p>



<p><strong>Abbott: Now you’ve got it.<br>
Costello: I throw the ball to Naturally.<br>
Abbott: You don’t! You throw it to Who!<br>
Costello: Naturally.<br>
Abbott: Well, that’s it - say it that way.<br>
Costello: That’s what I said.</strong> - <strong>Abbott and Costello on Effective
Communication</strong></p>

<p>In simple embedded systems and early computers, processes directly
access memory – “Address 1234” corresponds to a particular byte stored
in a particular part of physical memory. For example, the IBM 709 had to
read and write directly to tape with no level of abstraction ((IBM),
August 1958 P. 65). Even in systems after that, it was hard to adopt
virtual memory because virtual memory required the whole fetch cycle to
be altered through hardware – a change many manufacturers still thought
was expensive. In the PDP-10, a workaround was used by using different
registers for each process and then virtual memory was added later (“DEC
Pdp-10 Ka10 Control Panel,” <a href="#ref-ricm" class="fancy-link wiki-link">#ref-ricm</a>). In
modern systems, this is no longer the case. Instead, each process is
isolated, and there is a translation process between the address of a
particular CPU instruction or piece of data of a process and the actual
byte of physical memory (“RAM”). Memory addresses no longer map to
physical addresses The process runs inside virtual memory. Virtual
memory keeps processes safe because one process cannot directly read or
modify another process’s memory. Virtual memory also allows the system
to efficiently allocate and reallocate portions of memory to different
processes. The modern process of translating memory is as follows.</p>

<ol>
  <li>
    <p>A process makes a memory request</p>
  </li>
  <li>
    <p>The circuit first checks the Translation Lookaside Buffer (TLB) if
the address page is cached into memory. It skips to the reading
from/writing to phase if found otherwise the request goes to the
MMU.</p>
  </li>
  <li>
    <p>The Memory Management Unit (MMU) performs the address translation.
If the translation succeeds, the page gets pulled from RAM –
conceptually the entire page isn’t loaded up. The result is cached
in the TLB.</p>
  </li>
  <li>
    <p>The CPU performs the operation by either reading from the physical
address or writing to the address.</p>
  </li>
</ol>

<div class="pad"><div class="card">
<div class="title"><h2 id="translating-addresses" class="title-text">Translating Addresses<a class="anchor title-text" href="#translating-addresses"> #</a>
</h2></div>











\[2^{32} \text{address} / 2^{12} \text{(address/page)} = 2^{20} \text{pages}.\]



\[2^{64} \text{address} / 2^{12} \text{(address/page)} = 2^{52} \text{pages} ≈10^{15} \text{pages}.\]







































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>The Memory Management Unit is part of the CPU, and it converts a virtual
memory address into a physical address. First, we’ll talk about what the
virtual memory abstraction is and how to translate addresses</p>
<p>To illustrate, consider a 32-bit machine, meaning pointers are 32-bits.
They can address \(2^{32}\) different locations or 4GB of memory where
one address is one byte. Imagine we had a large table for every possible
address where we will store the ‘real’ i.e.  physical address. Each
physical address will need 4 bytes – to hold the 32-bits. Naturally,
This scheme would require 16 billion bytes to store all of the entries.
It should be painfully obvious that our lookup scheme would consume all
of the memory that we could buy for our 4GB machine. Our lookup table
should be smaller than the memory we have otherwise we will have no
space left for our actual programs and operating system data. The
solution is to chunk memory into small regions called ‘pages’ and
‘frames’ and use a lookup table for each page.</p>
<h3 id="terminology" class="title-text">Terminology</h3>
<p>A <strong>page</strong> is a block of virtual memory. A typical block size on Linux
is 4KiB or \(2^{12}\) addresses, though one can find examples of
larger blocks. So rather than talking about individual bytes, we can
talk about blocks of 4KiBs, each block is called a page. We can also
number our pages (“Page 0” “Page 1” etc). Let’s do a sample calculation
of how many pages are there assume page size of 4KiB.</p>
<p>For a 32-bit
machine,</p>
<p>For a 64-bit
machine,</p>
<p>We also call this a <strong>frame</strong> or sometimes called a ‘page frame’ is a
block of <em>physical memory</em> or RAM – Random Access Memory. A frame is the
same number of bytes as a virtual page or 4KiB on our machine. It stores
the bytes of interest. To access a particular byte in a frame, an MMU
goes from the start of the frame and adds the offset – discussed later.</p>
<p>A <strong>page table</strong> is a map from a number to a particular frame. For
example Page 1 might be mapped to frame 45, page 2 mapped to frame 30.
Other frames might be currently unused or assigned to other running
processes or used internally by the operating system. Implied from the
name, imagine a page table as a table.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/frame_table.png" alt="Explicit Frame
Table"></p>
<p>In practice, we will omit the first column because it will always be
sequentially 0, 1, 2, etc and instead we’ll use the offset from the
start of the table as the entry number.</p>
<p>Now to go through the actual calculations. We will assume that a 32-bit
machine has 4KiB pages Naturally, to address all the possible entries,
there are \(2^{20}\) frames. Since there are \(2^{20}\) possible
frames, we will need 20 bits to number all of the possible frames
meaning <code class="language-plaintext highlighter-rouge">Frame Number</code> must be 2.5 bytes long. In practice, we’ll round
that up to 4 bytes and do something interesting with the rest of the
bits. With 4 bytes per entry x \(2^{20}\) entries = 4 MiB of physical
memory are required to hold the entire page table for a process.</p>
<p>Remember our page table maps pages to frames, but each frame is a block
of contiguous addresses. How do we calculate which particular byte to
use inside a particular frame? The solution is to re-use the lowest bits
of the virtual memory address directly. For example, suppose our process
is reading the following address- <code class="language-plaintext highlighter-rouge">VirtualAddress
= 11110000111100001111000010101010 (binary)</code></p>
<p>So to give an example say we have the virtual address above. How would
we split it up using a one-page table to frame scheme?</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/address_split.png" alt="Splitting
Address"></p>
<p>We can imagine the steps to dereference as one process. In general, it
looks like the following.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/level_split.png" alt="One level
dereference"></p>
<p>The way to read from a particular address above is visualized below.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/level_split_filled.png" alt="One level dereference
example"></p>
<p>And if we were reading from it, ’return’ that value. This sounds like a
perfect solution. Take each address and map it to a virtual address in
sequential order. The process will believe that the address looks
continuous, but the top 20 bits are used to figure out <code class="language-plaintext highlighter-rouge">page_num</code>, which
will allow us to find the frame number, find the frame, add the
<strong>offset</strong> – derived from the last 12 bits – and do the read or write.</p>
<p>There are other ways to split it as well. On a machine with page size
256 Bytes, then the lowest 8 bits (10101010) will be used as the offset.
The remaining upper bits will be the page number
(111100001111000011110000). This offset is treated as a binary number
and is added to the start of the frame when we get it.</p>
<p>We do have a problem with 64-bit operating systems. For a 64-bit machine
with 4KiB pages, each entry needs 52 bits. Meaning we need roughly With
\(2^{52}\) entries, that’s \(2^{55}\) bytes (roughly 40 petabytes).
So our page table is too large. In 64-bit architecture, memory addresses
are sparse, so we need a mechanism to reduce the page table size, given
that most of the entries will never be used. We’ll take about this
below. There is one last piece of terminology that needs to be covered.</p>
<h3 id="multi-level-page-tables" class="title-text">Multi-level page tables</h3>
<p>Multi-level pages are one solution to the page table size issue for
64-bit architectures. We’ll look at the simplest implementation - a
two-level page table. Each table is a list of pointers that point to the
next level of tables, som sub-tables may be omitted. An example, a
two-level page table for a 32-bit architecture is shown below.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/three_address_split.png" alt="Three Way Address
Split"></p>
<p>So what is the intuition for dereferencing an address? First, the MMU
takes the top-level page table and find the <code class="language-plaintext highlighter-rouge">Index1</code>’th entry. That will
contain a number that will lead the MMU to the appropriate sub-table
Then go to the <code class="language-plaintext highlighter-rouge">Index2</code>’th entry of that table. That will contain a
frame number. This is the good old fashioned 4KiB RAM that we were
talking about earlier. Then, the MMU adds the offset and do the read or
write.</p>
<div class="pad"><div class="card">
<h4 id="visualizing-the-dereference">Visualizing The Dereference</h4>

<p>In one diagram, the dereference looks like the following image.</p>

<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/multi_level_split.png" alt="Full page table
dereference"></p>

<p>Following our example, here is what the dereference would look like.</p>

<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/multi_level_filled.png" alt="Full page example
dereference"></p>

</div></div>
<div class="pad"><div class="card">
<h4 id="calculating-size-concerns">Calculating Size Concerns</h4>

<p>Now some calculations on size. Each <code class="language-plaintext highlighter-rouge">page_table_num</code> index is 10 bits
wide because there are only \(2^{10}\) possible <code class="language-plaintext highlighter-rouge">sub-tables</code>, so we
need 10 bits to store each directory index. We’ll round up to 2 bytes
for the sake of reasoning. If 2 bytes are used for each entry in the
top-level table and there are only \(2^{10}\) entries, we only need
2KiB to store this entire first level page table. Each subtable will
point to physical frames, and each of their entries needs to be the
required 4 bytes to be able to address all the frames as mentioned
earlier. However, for processes with only tiny memory needs, we only
need to specify entries for low memory addresses for the heap and
program code and high memory addresses for the stack.</p>

<p>Thus, the total memory overhead for our multi-level page table has
shrunk from 4MiB for the single-level implementation to three page
tables of memory or 2KiB for the top-level and 4KiB for the two
intermediate levels of size 10KiB. Here’s why. We need at least one
frame for the high-level directory and two frames for two sub-tables.
One sub-table is necessary for the low addresses – program code,
constants and possibly a tiny heap. The other sub-table is for higher
addresses used by the environment and stack. In practice, real programs
will likely need more sub-table entries, as each subtable can only
reference 1024*4KiB = 4MiB of address space. The main point still
stands. We have significantly reduced the memory overhead required to
perform page table lookups.</p>

<h3 id="page-table-disadvantages" class="title-text">Page Table Disadvantages</h3>

<p>There are lots of problems with page tables – one of the big problems is
that they are slow. For a single page table, our machine is now twice as
slow! Two memory accesses are required. For a two-level page table,
memory access is now three times as slow – three memory accesses are
required.</p>

<p>To overcome this overhead, the MMU includes an associative cache of
recently-used virtual-page-to-frame lookups. This cache is called the
TLB (“translation lookaside buffer”). Every time a virtual address needs
to be translated into a physical memory location, the TLB is queried in
parallel to the page table. For most memory accesses of most programs,
there is a significant chance that the TLB has cached the results.
However, if a program has inadequate cache coherence, the address will
be missing in the TLB, meaning the MMU must use the much slower page
table translation.</p>

<h3 id="mmu-algorithm" class="title-text">MMU Algorithm</h3>

<p>There is a sort of pseudocode associated with the MMU. We will assume
that this is for a single-level page table.</p>

<ol>
  <li>
    <p>Receive address</p>
  </li>
  <li>
    <p>Try to translate address according to the programmed scheme</p>
  </li>
  <li>
    <p>If the translation fails, report an invalid address</p>
  </li>
  <li>
    <p>Otherwise,</p>

    <ol>
      <li>
        <p>If the TLB contains the physical memory, get the physical frame
from the TLB and perform the read and write.</p>
      </li>
      <li>
        <p>If the page exists in memory, check if the process has
permissions to perform the operation on the page meaning the
process has access to the page, and it is reading from the
page/writing to a page that it has permission to do so.</p>

        <ol>
          <li>
            <p>If so then do the dereference provide the address, cache the
results in the TLB</p>
          </li>
          <li>
            <p>Otherwise, trigger a hardware interrupt. The kernel will
most likely send a SIGSEGV or a Segmentation Violation.</p>
          </li>
        </ol>
      </li>
      <li>
        <p>If the page doesn’t exist in memory, generate an Interrupt.</p>

        <ol>
          <li>
            <p>The kernel could realize that this page could either be not
allocated or on disk. If it fits the mapping, allocate the
page and try the operation again.</p>
          </li>
          <li>
            <p>Otherwise, this is invalid access and the kernel will most
likely send a SIGSEGV to the process.</p>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>How would you alter this for a multi-level page table?</p>

<h3 id="frames-and-page-protections" class="title-text">Frames and Page Protections</h3>

<p>Frames can be shared between processes, and this is where the heart of
the chapter comes into play. We can use these tables to communicate with
processes. In addition to storing the frame number, the page table can
be used to store whether a process can write or only read a particular
frame. Read-only frames can then be safely shared between multiple
processes. For example, the C-library instruction code can be shared
between all processes that dynamically load the code into the process
memory. Each process can only read that memory. Meaning that if a
program tries to write to a read-only page in memory, it will
<code class="language-plaintext highlighter-rouge">SEGFAULT</code>. That is why sometimes memory accesses SEGFAULT and sometimes
they don’t, it all depends on if your hardware says that a program can
access.</p>

<p>Also, processes can share a page with a child process using the <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code>
system call. <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code> is an interesting call because instead of tying each
virtual address to a physical frame, it ties it to something else. It is
an important distinction that we are talking about mmap and not
memory-mapped IO in general. The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code> system call can’t reliably be
used to do other memory-mapped operations like communicate with GPUs and
write pixels to the screen – this is mainly hardware dependent.</p>

</div></div>
<div class="pad"><div class="card">
<h4 id="bits-on-pages">Bits on Pages</h4>

<p>This is <em>heavily</em> dependent on the chipset. We will include some bits
that have historically been popular in chipsets.</p>

<ol>
  <li>
    <p>The read-only bit marks the page as read-only. Attempts to write to
the page will cause a page fault. The page fault will then be
handled by the Kernel. Two examples of the read-only page include
sharing the C standard library between multiple processes for
security you wouldn’t want to allow one process to modify the
library and Copy-On-Write where the cost of duplicating a page can
be delayed until the first write occurs.</p>
  </li>
  <li>
    <p>The execution bit defines whether bytes in a page can be executed as
CPU instructions. Processors may merge these bits into one and deem
a page either writable or executable. This bit is useful because it
prevents stack overflow or code injection attacks when writing user
data into the heap or the stack because those are not read-only and
thus not executable. Further reading:
<a href="http://en.wikipedia.org/wiki/NX_bit#Hardware_background" class="fancy-link wiki-link">http://en.wikipedia.org/wiki/NX_bit#Hardware_background</a></p>
  </li>
  <li>
    <p>The dirty bit allows for performance optimization. A page
exclusively read from can be discarded without syncing to disk,
since the page hasn’t changed. However, if the page was written to
after it’s paged in, its dirty bit will be set, indicating that the
page must be written back to the backing store. This strategy
requires that the backing store retain a copy of the page after it
is paged into memory. When a dirty bit is omitted, the backing store
need only be as large as the instantaneous total size of all
paged-out pages at any moment. When a dirty bit is used, at all
times some pages will exist in both physical memory and the backing
store.</p>
  </li>
  <li>
    <p>There are plenty of other bits. Take a look at your favorite
architecture and see what other bits are associated!</p>
  </li>
</ol>

<h3 id="page-faults" class="title-text">Page Faults</h3>

<p>A page fault may happen when a process accesses an address in a frame
missing in memory. There are three types of Page Faults</p>

<ol>
  <li>
    <p><strong>Minor</strong> If there is no mapping yet for the page, but it is a valid
address. This could be memory asked for by <code class="language-plaintext highlighter-rouge">sbrk(2)</code> but not written
to yet meaning that the operating system can wait for the first
write before allocating space – if it was read from, the operating
system could short circuit the operation to read 0. The OS simply
makes the page, loads it into memory, and moves on.</p>
  </li>
  <li>
    <p><strong>Major</strong> If the mapping to the page is exclusively on disk. The
operating system will swap the page into memory and swap another
page out. If this happens frequently enough, your program is said to
<em>thrash</em> the MMU.</p>
  </li>
  <li>
    <p><strong>Invalid</strong> When a program tries to write to a non-writable memory
address or read to a non-readable memory address. The MMU generates
an invalid fault and the OS will usually generate a <code class="language-plaintext highlighter-rouge">SIGSEGV</code>
meaning segmentation violation meaning that the program wrote
outside the segment that it could write to.</p>
  </li>
</ol>

<h3 id="link-back-to-ipc" class="title-text">Link Back to IPC</h3>

<p>What does this have to do with IPC? Before, you knew that processes had
isolation. One, you didn’t know how that isolation mapped. Two, you may
not know how you can break this isolation. To break any memory level
isolation you have two avenues. One is to ask the kernel to provide some
kind of interface. The other is to ask the kernel to map two pages of
memory to the same virtual memory area and handle all the
synchronization yourself.</p>

</div></div>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="mmap" class="title-text">mmap<a class="anchor title-text" href="#mmap"> #</a>
</h2></div>



































<!-- end list -->



























<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code> is a trick of virtual memory of instead of mapping a page to a
frame, that frame can be backed by a file on disk, or the frame can be
shared among processes. We can use that to read from a file on disk
efficiently or sync changes to the file. One of the big optimizations is
a file may be lazily allocated to memory. Take the following code for
example.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(...);</span> <span class="c1">//File is 2 Pages</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(..</span><span class="n">fd</span><span class="p">..);</span>
    <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>
</code></pre></div></div>
<p>The kernel sees that the program wants to mmap the file into memory, so
it will reserve some space in your address space that is the length of
the file. That means when the program writes to <code class="language-plaintext highlighter-rouge">addr[0]</code> that it writes
to the first byte of the file. The kernel can do some optimizations too.
Instead of loading the whole file into memory, it may only load pages at
a time. A program may only access 3 or 4 pages making loading the entire
file a waste of time. Page faults are so powerful because let the
operating system take control of when a file is used.</p>
<h3 id="mmap-definitions" class="title-text">mmap Definitions</h3>
<p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code> does more than take a file and map it to memory. It is the
general interface for creating shared memory among processes. Currently
it only supports regular files and POSIX <code class="language-plaintext highlighter-rouge">shmem</code> (“Mmap”
<a href="#ref-mmap_2018" class="fancy-link wiki-link">#ref-mmap_2018</a>). Naturally, you can read
all about it in the reference above, which references the current
working group POSIX standard. Some other options to note in the page
will follow.</p>
<p>The first option is that the <code class="language-plaintext highlighter-rouge">flags</code> argument of mmap can take many
options.</p>
<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PROT_READ</code> This means the process can read the memory. This isn’t
the only flag that gives the process read permission, however! The
underlying file descriptor, in this case, must be opened with read
privileges.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PROT_WRITE</code> This means the process can write to the memory. This
has to be supplied for a process to write to a mapping. If this is
supplied and <code class="language-plaintext highlighter-rouge">PROT_NONE</code> is also supplied, the latter wins and no
writes can be performed. The underlying file descriptor, in this
case, must either be opened with write privileges or a private
mapping must be supplied below</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PROT_EXEC</code> This means the process can execute this piece of memory.
Although this is not stated in POSIX documents, this shouldn’t be
supplied with WRITE or NONE because that would make this invalid
under the NX bit or not being able to execute (respectively)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PROT_NONE</code> This means the process can’t do anything with the
mapping. This could be useful if you implement guard pages in terms
of security. If you surround critical data with many more pages that
can’t be accessed, that decreases the chance of various attacks.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MAP_SHARED</code> This mapping will be synchronized to the underlying
file object. The file descriptor must’ve been opened with write
permissions in this case.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code> This mapping will only be visible to the process
itself. Useful to not thrash the operating system.</p>
  </li>
</ol>
<p>Remember that once a program is done <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code>ping that the program must
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/munmap.3p.html" class="fancy-link">munmap</a></code> to tell the operating system that it is no longer using the
pages allocated, so the OS can write it back to disk and give back the
addresses in case another mmap needs to occur. There are accompanying
calls <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/msync.3p.html" class="fancy-link">msync</a></code> that take a piece of mmap’ed memory and sync the changes
back to the filesystem though we won’t cover that in-depth. The other
parameters to mmap are described in the annotated walkthrough below.</p>
<h3 id="annotated-mmap-walkthrough" class="title-text">Annotated mmap Walkthrough</h3>
<p>Below is an annotated walkthrough of the example code in the man pages.
Our command-line utility will take a file, offset, and length to print.
We can assume that these are initialized correctly and the offset +
length is less than the length of the file.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">off_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>
<p>We’ll assume that all system calls succeed. First, we have to open the
file and get the size.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">stat</span> <span class="n">sb</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">);</span>
</code></pre></div></div>
<p>Then, we need to introduce another variable known as <code class="language-plaintext highlighter-rouge">page_offset</code>. mmap
doesn’t let the program pass in any value as an offset, it needs to be a
multiple of the page size. In our case, we will round down.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">off_t</span> <span class="n">page_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>Then, we make the call to mmap, here is the order of arguments.</p>
<ol>
  <li>
    <p>NULL, this tells mmap we don’t need any particular address to start
from</p>
  </li>
  <li>
    <p>length + offset - page_offset, mmaps the “rest” of the file into
memory (starting from offset)</p>
  </li>
  <li>
    <p>PROT_READ, we want to read the file</p>
  </li>
  <li>
    <p>MAP_PRIVATE, tell the OS, we don’t want to share our mapping</p>
  </li>
  <li>
    <p>fd, object descriptor that we refer to</p>
  </li>
  <li>
    <p>pa_offset, the page aligned offset to start from</p>
  </li>
</ol>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">char</span> <span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span>
     <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">page_offset</span><span class="p">);</span>
</code></pre></div></div>
<p>Now, we can interact with the address as if it were a normal buffer.
After, we have to unmap the file and close the file descriptor to make
sure other system resources are freed.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">page_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">pa_offset</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</code></pre></div></div>
<p>Check out the full listing in the man pages.</p>
<h3 id="mmap-communication" class="title-text">MMAP Communication</h3>
<p>So how would we use mmap to communicate across processes? Conceptually,
it would be the same as using threading. Let’s go through a broken down
example. First, we need to allocate some space. We can do that with the
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mmap.3p.html" class="fancy-link">mmap</a></code> call. We’ll also allocate space for 100 integers</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
</code></pre></div></div>
<p>Then, we need to fork and perform some communication. Our parent will
store some values, and our child will read those values.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">pid_t</span> <span class="n">mychild</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mychild</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">shared</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
     <span class="n">shared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Check the synchronization chapter for a better way</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">shared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shared</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Now, there is no assurance that the values will be communicated because
the process used <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/sleep.3p.html" class="fancy-link">sleep</a></code>, not a mutex. Most of the time this will work.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> /* mmap() is defined in this header */</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     
     <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     
     <span class="n">printf</span><span class="p">(</span><span class="s">"Mapped at %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
     
     <span class="kt">int</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
     <span class="n">pid_t</span> <span class="n">mychild</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">mychild</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">shared</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
     <span class="n">shared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// We will talk about synchronization later</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">shared</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shared</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
     <span class="p">}</span>
     
     <span class="n">munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>This piece of code allocates space for a 100 integers and creates a
piece of memory that is shared between all processes. The code then
forks. The parent process writes two integers to the first two slots. To
avoid a data race, the child sleeps for a second and then prints out the
stored values. This is an imperfect way to protect against data races.
We could use a mutex across the processes mentioned in the
synchronization section. But for this simple example, it works fine.
Note that each process should call munmap when done using the piece of
memory.</p>
<p>Sharing anonymous memory is an efficient form of inter-process
communication because there is no copying, system call, or disk-access
overhead - the two processes share the same physical frame of main
memory. On the other hand, shared memory, like in a multithreading
context, creates room for data races. Processes that share writable
memory might need to use synchronization primitives like mutexes to
prevent these from happening.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="pipes" class="title-text">Pipes<a class="anchor title-text" href="#pipes"> #</a>
</h2></div>



































































































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>You’ve seen the virtual memory way of IPC, but there are more standard
versions of IPC that are provided by the kernel. One of the big
utilities is POSIX pipes. A pipe simply takes in a stream of bytes and
spits out a sequence of bytes.</p>
<p>One of the big starting points of pipes was way back in the PDP-10 days.
In those days, a write to the disk or even your terminal was slow as it
may have to be printed out. The Unix programmers still wanted to create
small, portable programs that did one thing well and could be composed.
As such, pipes were invented to take the output of one program and feed
it to the input of another program though they have other uses today –
you can read more
<a href="https://en.wikipedia.org/wiki/Pipeline_%28Unix%29" class="fancy-link wiki-link">https://en.wikipedia.org/wiki/Pipeline_%28Unix%29</a>
Consider if you type the following into your terminal.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-1</span> | <span class="nb">cut</span> <span class="nt">-d</span><span class="s1">'.'</span> <span class="nt">-f1</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> | <span class="nb">tee </span>dirents
</code></pre></div></div>
<p>What does the following code do? First, it lists the current directory.
The -1 means that it outputs one entry per line. The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/cut.1p.html" class="fancy-link">cut</a></code> command then
takes everything before the first period. <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/sort.1p.html" class="fancy-link">sort</a></code> sorts all the input
lines, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/uniq.1p.html" class="fancy-link">uniq</a></code> makes sure all the lines are unique. Finally, <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man2/tee.2.html" class="fancy-link">tee</a></code>
outputs the contents to the file <code class="language-plaintext highlighter-rouge">dir_contents</code> and the terminal for
your perusal. The important part is that bash creates <strong>5 separate
processes</strong> and connects their standard outs/stdins with pipes the trail
looks something like this.</p>
<p class="img-paragraph"><img src="https://raw.githubusercontent.com/illinois-cs241/coursebook/master/ipc/drawings/pipe_process.png" alt="Pipe Process Filedescriptor
redirection"></p>
<p>The numbers in the pipes are the file descriptors for each process and
the arrow represents the redirect or where the output of the pipe is
going. A POSIX pipe is almost like its real counterpart - a program can
stuff bytes down one end and they will appear at the other end in the
same order. Unlike real pipes, however, the flow is always in the same
direction, one file descriptor is used for reading and the other for
writing. The <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/pipe.3p.html" class="fancy-link">pipe</a></code> system call is used to create a pipe. These file
descriptors can be used with <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code>. A common method of
using pipes is to create the pipe before forking to communicate with a
child process</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">pipe</span> <span class="p">(</span><span class="n">filedes</span><span class="p">);</span>
    <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* I must be the parent */</span>
     <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
     <span class="kt">int</span> <span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
     <span class="c1">// do something with the bytes read</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"done"</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>There are two file descriptors that pipe creates. <code class="language-plaintext highlighter-rouge">filedes[0]</code> contains
the read end. <code class="language-plaintext highlighter-rouge">filedes[1]</code> contains the write end. How your friendly
neighborhood TAs remember it is one can <em>read before they can write, or
reading comes before writing</em>. You can groan all you want at it, but it
is helpful to remember what is the read end and what is the write end.</p>
<p>One can use pipes inside of the same process, but there tends to be no
added benefit. Here’s an example program that sends a message to itself.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="n">pipe</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
     <span class="kt">FILE</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
     <span class="kt">FILE</span> <span class="o">*</span><span class="n">writer</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"w"</span><span class="p">);</span>
     <span class="c1">// Hurrah now I can use printf</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Writing...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
     <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span><span class="s">"%d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
     <span class="n">fflush</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
     
     <span class="n">printf</span><span class="p">(</span><span class="s">"Reading...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
     <span class="kt">int</span> <span class="n">results</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
     <span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">fscanf</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span><span class="s">"%d %d %d"</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">results</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">results</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d values parsed: %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ok</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
     
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>The problem with using a pipe in this fashion is that writing to a pipe
can block meaning the pipe only has a limited buffering capacity. The
maximum size of the buffer is system-dependent; typical values from 4KiB
up to 128KiB though they can be changed.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="n">pipe</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
     <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="cp">#define MESG "..............................."
</span>     <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
     <span class="n">write</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">MESG</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MESG</span><span class="p">))</span>
     <span class="n">b</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MESG</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<h3 id="pipe-gotchas" class="title-text">Pipe Gotchas</h3>
<p>Here’s a complete example that doesn’t work! The child reads one byte
at a time from the pipe and prints it out - but we never see the
message! Can you see why?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
     <span class="c1">//You must read from fd[0] and write from fd[1]</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Reading from %d, writing to %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
     
     <span class="n">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="cm">/* I have a child, therefore I am the parent */</span>
     <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"Hi Child!"</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>
     
     <span class="cm">/*don't forget your child*/</span>
     <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="n">buf</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">bytesread</span><span class="p">;</span>
     <span class="c1">// read one byte at a time.</span>
     <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>The parent sends the bytes <code class="language-plaintext highlighter-rouge">H,i,(space),C...!</code> into the pipe. The child
starts reading the pipe one byte at a time. In the above case, the child
process will read and print each character. However, it never leaves the
while loop! When there are no characters left to read it simply blocks
and waits for more unless <strong>All the writers close their ends</strong> Another
solution could also exit the loop by checking for an end-of-message
marker,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">while</span> <span class="p">((</span><span class="n">bytesread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">putchar</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">'!'</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* End of message */</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>We know that when a process tries to read from a pipe where there are
still writers, the process blocks. If no pipe has no writers, read
returns 0. If a process tries to write with some reader’s read goes
through, or fails – partially or completely – if the pipe is full. Why
happens when a process tries to write when there are no readers
left?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    If all file descriptors referring to the read end of a pipe have been closed,
    then a write(2) will cause a SIGPIPE signal to be generated for the calling process.
</code></pre></div></div>
<p>Tip: Notice only the writer (not a reader) can use this signal. To
inform the reader that a writer is closing their end of the pipe, a
program could write your special byte (e.g. 0xff) or a message
(<code class="language-plaintext highlighter-rouge">"Bye!"</code>)</p>
<p>Here’s an example of catching this signal that fails! Can you see why?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>     
    <span class="kt">void</span> <span class="nf">no_one_listening</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"No one is listening!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
    <span class="p">}</span>
     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">no_one_listening</span><span class="p">);</span>
     <span class="kt">int</span> <span class="n">filedes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     
     <span class="n">pipe</span><span class="p">(</span><span class="n">filedes</span><span class="p">);</span>
     <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="cm">/* This process is the parent. Close the listening end of the pipe */</span>
     <span class="n">close</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="cm">/* Child writes messages to the pipe */</span>
     <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"One"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
     <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
     <span class="c1">// Will this write generate SIGPIPE ?</span>
     <span class="n">write</span><span class="p">(</span><span class="n">filedes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"Two"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
     <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>The mistake in the above code is that there is still a reader for the
pipe! The child still has the pipe’s first file descriptor open and
remember the specification? All readers must be closed</p>
<p>When forking, <em>It is common practice</em> to close the unnecessary (unused)
end of each pipe in the child and parent process. For example, the
parent might close the reading end and the child might close the writing
end.</p>
<p>The last addendum is that a program can set the file descriptor to
return when there is no one listening instead of SIGPIPE because by
default SIGPIPE terminates your program. The reason that this is default
behavior is it makes the pipe example above work. Consider this useless
use of cat</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span><span class="nb">cat</span> /dev/urandom | <span class="nb">head</span> <span class="nt">-n</span> 20
</code></pre></div></div>
<p>Which grabs 20 lines of input from urandom. <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/head.1p.html" class="fancy-link">head</a></code> will terminate after
20 newline characters have been read. What about <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/cat.1p.html" class="fancy-link">cat</a></code>? <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man1/cat.1p.html" class="fancy-link">cat</a></code> needs to
receive a SIGPIPE informing it that the program tried to write to a pipe
that no one is listening on.</p>
<h3 id="other-pipe-facts" class="title-text">Other pipe facts</h3>
<p>A pipe gets filled up when the writer writes too much to the pipe
without the reader reading any of it. When the pipes become full, all
writes fail until a read occurs. Even then, a write may partially fail
if the pipe has a little bit of space left but not enough for the entire
message. Usually, two things are done to avoid this. Either increase the
size of the pipe. Or more commonly, fix your program design so that the
pipe is constantly being read from.</p>
<p>As hinted at before, Pipe writes are atomic up to the size of the pipe.
Meaning that if two processes try to write to the same pipe, the kernel
has internal mutexes with the pipe that it will lock, do the write, and
return. The only gotcha is when the pipe is about to become full. If two
processes are trying to write and the pipe can only satisfy a partial
write, that pipe write is not atomic – be careful about that!</p>
<p>Unnamed pipes live in memory and are a simple and efficient form of
inter-process communication (IPC) that is useful for streaming data and
simple messages. Once all processes have closed, the pipe resources are
freed.</p>
<p>It is also common design for a pipe to be one way – meaning one process
should do the writing and one process do the reading. Otherwise, the
child would attempt to read its data intended for the parent (and vice
versa)!</p>
<h3 id="pipes-and-dup" class="title-text">Pipes and Dup</h3>
<p>Often, you’ll want to use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man2/pipe2.2.html" class="fancy-link">pipe2</a></code> in combination with dup. Take for
example the simple program in the command line.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-1</span> | <span class="nb">cut</span> <span class="nt">-f1</span> <span class="nt">-d</span><span class="nb">.</span>
</code></pre></div></div>
<p>This command takes the output of <code class="language-plaintext highlighter-rouge">ls -1</code> which lists the content of the
current directory on one line each and pipes it to cut. Cut take a
delimiter, in this case, a dot, and a field position, in our case 1, and
outputs per line the nth field by each delimiter. At a high level, this
grabs the file names without the extension of our current directory.</p>
<p>Underneath the hood, this is how bash does it internally.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#define _GNU_SOURCE
</span>     
    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     
     <span class="kt">int</span> <span class="n">pipe_fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="c1">// Call with the O_CLOEXEC flag to prevent any commands from blocking</span>
     <span class="n">pipe2</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">,</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
     
     <span class="c1">// Remember for pipe_fds, the program read then write (reading is 0 and writing is 1)</span>
     
     <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
     <span class="c1">// Child</span>
     
     <span class="c1">// Make the stdout of the process, the write end</span>
     <span class="n">dup2</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
     
     <span class="c1">// Exec! Don't forget the cast</span>
     <span class="n">execlp</span><span class="p">(</span><span class="s">"ls"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"-1"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
     <span class="p">}</span>
     
     <span class="c1">// Same here, except the stdin of the process is the read end</span>
     <span class="n">dup2</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
     
     <span class="c1">// Same deal here</span>
     <span class="n">execlp</span><span class="p">(</span><span class="s">"cut"</span><span class="p">,</span> <span class="s">"cut"</span><span class="p">,</span> <span class="s">"-f1"</span><span class="p">,</span> <span class="s">"-d."</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
     
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>The results of the two programs should be the same. Remember as you
encounter more complicated examples of piping processes up, a program
needs to close all unused ends of pipes otherwise the program will
deadlock waiting for your processes to finish.</p>
<h3 id="pipe-conveniences" class="title-text">Pipe Conveniences</h3>
<p>If the program already has a file descriptor, it can ‘wrap’ it yourself
into a FILE pointer using <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fdopen.3p.html" class="fancy-link">fdopen</a></code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">=</span><span class="s">"Fred"</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">filedes</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"mydata.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">);</span>
     
     <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">filedes</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
     <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Name:%s Score:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
     <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>
<p>For writing to files, this is unnecessary. Use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fopen.3p.html" class="fancy-link">fopen</a></code> which does the
same as <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/open.3p.html" class="fancy-link">open</a></code> and <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fdopen.3p.html" class="fancy-link">fdopen</a></code>. However for pipes, we already have a file
descriptor, so this is a great time to use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fdopen.3p.html" class="fancy-link">fdopen</a></code></p>
<p>Here’s a complete example using pipes that almost works! Can you spot
the error? Hint: The parent never prints anything!</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">fh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
     <span class="n">pipe</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
     <span class="kt">FILE</span> <span class="o">*</span><span class="n">reader</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"r"</span><span class="p">);</span>
     <span class="kt">FILE</span> <span class="o">*</span><span class="n">writer</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"w"</span><span class="p">);</span>
     <span class="n">pid_t</span> <span class="n">p</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">score</span><span class="p">;</span>
     <span class="n">fscanf</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">score</span><span class="p">);</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"The child says the score is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
     <span class="n">fflush</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Note the unnamed pipe resource will disappear once both the child and
parent have exited. In the above example, the child will send the bytes
and the parent will receive the bytes from the pipe. However, no
end-of-line character is ever sent, so <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fscanf.3p.html" class="fancy-link">fscanf</a></code> will continue to ask for
bytes because it is waiting for the end of the line i.e. it will wait
forever! The fix is to ensure we send a newline character so that
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fscanf.3p.html" class="fancy-link">fscanf</a></code> will return.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nl">change:</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">to</span><span class="o">:</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="s">"Score %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<p>If you want your bytes to be sent to the pipe immediately, you’ll need
to fflush! Remember back to the introduction section that shows the
difference between terminal vs non-terminal outputs of stdout.</p>
<p><strong>Even though we have a section on it, it is highly not recommended to
use the file descriptor API for non-seekable files</strong>. The reason being
is that while we get conveniences we also get annoyances like the
buffering example we mentioned, caching, etc. The basic C library motto
is that any device a program can properly <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fseek.3p.html" class="fancy-link">fseek</a></code> or move to an
arbitrary position, it should be able to <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fdopen.3p.html" class="fancy-link">fdopen</a></code>. Files satisfy this
behavior, shared memory also, terminals, etc. When it comes to pipes,
sockets, epoll objects, etc, don’t do it.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="named-pipes" class="title-text">Named Pipes<a class="anchor title-text" href="#named-pipes"> #</a>
</h2></div>































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>An alternative to <em>unnamed</em> pipes is <em>named</em> pipes created using
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mkfifo.3p.html" class="fancy-link">mkfifo</a></code>. From the command line: <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mkfifo.3p.html" class="fancy-link">mkfifo</a></code> From C:
<code class="language-plaintext highlighter-rouge">int mkfifo(const char pathname, mode_t mode);</code></p>
<p>You give it the pathname and the operation mode, it will be ready to
go! Named pipes take up virtually no space on a file system. This means
the actual contents of the pipe aren’t printed to the file and read from
that same file. What the operating system tells you when you have a
named pipe is that it will create an unnamed pipe that refers to the
named pipe, and that’s it! There is no additional magic. This is for
programming convenience if processes are started without forking meaning
that there would be no way to get the file descriptor to the child
process for an unnamed pipe.</p>
<h3 id="hanging-named-pipes" class="title-text">Hanging Named Pipes</h3>
<p>A named pipe <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/mkfifo.3p.html" class="fancy-link">mkfifo</a></code> is a pipe that a program calls <code class="language-plaintext highlighter-rouge">open(2)</code> on with
read and/or write permissions. This is useful if you want to have a pipe
between two processes without one processing having to fork the other
process. There are some gotchas with named pipes. There is more down
below, but we’ll introduce it here for a simple example. Reads and
writes hang on Named Pipes until there is at least one reader and one
writer, take this.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1<span class="nv">$ </span><span class="nb">mkfifo </span>fifo
    1<span class="nv">$ </span><span class="nb">echo </span>Hello <span class="o">&gt;</span> fifo
    <span class="c"># This will hang until the following command is run on another terminal or another process</span>
    2<span class="nv">$ </span><span class="nb">cat </span>fifo
    Hello
</code></pre></div></div>
<p>Any <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/open.3p.html" class="fancy-link">open</a></code> is called on a named pipe the kernel blocks until another
process calls the opposite open. Meaning, echo calls
<code class="language-plaintext highlighter-rouge">open(.., O_RDONLY)</code> but that blocks until cat calls
<code class="language-plaintext highlighter-rouge">open(.., O_WRONLY)</code>, then the programs are allowed to continue.</p>
<h3 id="race-condition-with-named-pipes" class="title-text">Race condition with named pipes</h3>
<p>What is wrong with the following program?</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//Program 1</span>
     
    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
     <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"fifo"</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>
     <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">"Hello!"</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
     <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
     
    <span class="c1">//Program 2</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
     <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"fifo"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
     <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
     <span class="n">buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>This may never print hello because of a race condition. Since a program
opened the pipe in the first process under both permissions, open won’t
wait for a reader because the program told the operating system that it
is a reader! Sometimes it looks like it works because the execution of
the code looks something like this.</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Process 1</th>
      <th style="text-align: center">Process 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Time 1</td>
      <td style="text-align: center">open(O_RDWR) &amp; write()</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Time 2</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">open(O_RDONLY) &amp; read()</td>
    </tr>
    <tr>
      <td style="text-align: center">Time 3</td>
      <td style="text-align: center">close() &amp; exit()</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Time 4</td>
      <td style="text-align: center">print() &amp; exit()</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>
<p>Fine Pipe Access Pattern</p>
<p>But here is an invalid series of operations that cause a race
condition.</p>
<table class="table">
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Process 1</th>
      <th style="text-align: center">Process 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Time 1</td>
      <td style="text-align: center">open(O_RDWR) &amp; write()</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Time 2</td>
      <td style="text-align: center">close() &amp; exit()</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Time 3</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">open(O_RDONLY) (Blocks Indefinitely)</td>
    </tr>
  </tbody>
</table>
<p>Pipe Race Condition</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="files" class="title-text">Files<a class="anchor title-text" href="#files"> #</a>
</h2></div>





































<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>On Linux, there are two abstractions with files. The first is the Linux
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man4/fd.4.html" class="fancy-link">fd</a></code> level abstraction.</p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/open.3p.html" class="fancy-link">open</a></code> takes a path to a file and creates a file descriptor entry in
the process table. If the file is inaccessible, it errors out.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/read.3p.html" class="fancy-link">read</a></code> takes a certain number of bytes that the kernel has received
and reads them into a user-space buffer. If the file is not open in
read mode, this will break.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/write.3p.html" class="fancy-link">write</a></code> outputs a certain number of bytes to a file descriptor. If
the file is not open in write mode, this will break. This may be
buffered internally.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/close.3p.html" class="fancy-link">close</a></code> removes a file descriptor from a process’ file descriptors.
This always succeeds for a valid file descriptor.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/lseek.3p.html" class="fancy-link">lseek</a></code> takes a file descriptor and moves it to a certain position.
It can fail if the seek is out of bounds.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fcntl.3p.html" class="fancy-link">fcntl</a></code> is the catch-all function for file descriptors. Set file
locks, read, write, edit permissions, etc.</p>
  </li>
</ul>
<p>The Linux interface is powerful and expressive, but sometimes we need
portability for example if we are writing for a Macintosh or windows.
This is where C’s abstraction comes into play. On different operating
systems, C uses the low-level functions to create a wrapper around files
used everywhere, meaning that C on Linux uses the above calls.</p>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fopen.3p.html" class="fancy-link">fopen</a></code> opens a file and returns an object. <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man4/null.4.html" class="fancy-link">null</a></code> is returned if
the program doesn’t have permission for the file.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fread.3p.html" class="fancy-link">fread</a></code> reads a certain number of bytes from a file. An error is
returned if already at the end of the file when which the program
must call <code class="language-plaintext highlighter-rouge">feof()</code> to check if the program attempted to read <em>past</em>
the end of the file.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">fgetc/fgets</code> Get a char or a string from a file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fscanf.3p.html" class="fancy-link">fscanf</a></code> Read a format string from the file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fwrite.3p.html" class="fancy-link">fwrite</a></code> Write some objects to a file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fprintf.3p.html" class="fancy-link">fprintf</a></code> Write a formatted string to a file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fclose.3p.html" class="fancy-link">fclose</a></code> Close a file handle</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fflush.3p.html" class="fancy-link">fflush</a></code> Take any buffered changes and flush them to a file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/feof.3p.html" class="fancy-link">feof</a></code> Returns true if you are at the end of a file</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/ferror.3p.html" class="fancy-link">ferror</a></code> Returns true if an error occured reading, writing or
seeking.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/setvbuf.3p.html" class="fancy-link">setvbuf</a></code> Sets the buffering (None,Line or Full) and the memory used
for buffering</p>
  </li>
</ul>
<p>But programs don’t get the expressiveness that Linux gives with system
calls. A program can convert back and forth between them with
<code class="language-plaintext highlighter-rouge">int fileno(FILE* stream)</code> and <code class="language-plaintext highlighter-rouge">FILE* fdopen(int fd...)</code>. Also, C files
are <strong>buffered</strong> meaning that their contents may be written to the
backing after the call returns. You can change that with C options.</p>
<h3 id="determining-file-length" class="title-text">Determining File Length</h3>
<p>For files less than the size of a long, using fseek and ftell is a
simple way to accomplish this. Move to the end of the file and find out
the current position.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
    <span class="kt">long</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>
<p>This tells us the current position in the file in bytes - i.e. the
length of the file!</p>
<p><code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fseek.3p.html" class="fancy-link">fseek</a></code> can also be used to set the absolute position.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span> <span class="c1">// Move to the start of the file</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">posn</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span> <span class="c1">// Move to 'posn' in the file.</span>
</code></pre></div></div>
<p>All future reads and writes in the parent or child processes will honor
this position. Note writing or reading from the file will change the
current position. See the man pages for fseek and ftell for more
information.</p>
<h3 id="use-stat-instead" class="title-text">Use stat instead</h3>
<p>This only works on some architectures and compilers That quirk is that
longs only need to be <strong>4 Bytes big</strong> meaning that the maximum size that
<code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/ftell.3p.html" class="fancy-link">ftell</a></code> can return is a little under 2 Gibibytes. Nowadays, our files
could be hundreds of gibibytes or even terabytes on a distributed file
system. What should we do instead? Use <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/stat.3type.html" class="fancy-link">stat</a></code>! We will cover stat in a
later part but here is some code that will tell a program the size of
the file</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">struct</span> <span class="n">stat</span> <span class="n">buf</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
     <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">buf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">buf.st_size</code> is of type <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/off_t.3type.html" class="fancy-link">off_t</a></code> which is big enough for large files.</p>
<h3 id="gotchas-with-files" class="title-text">Gotchas with files</h3>
<p>What happens when file streams are closed by two different processes?
Closing a file stream is unique to each process. Other processes can
continue to use their file handles. Remember, everything is copied over
when a child is created, even the relative positions of the files. As
you might have observed with using <code class="language-plaintext highlighter-rouge"><a href="https://man7.org/linux/man-pages/./man3/fork.3p.html" class="fancy-link">fork</a></code>, there is a quirk of the
implementation of files and their caches on Ubuntu that will rewind a
file descriptor once a file has been closed. As such, make sure to close
before forking or at least don’t trigger a cache inconsistency which is
much harder.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="ipc-alternatives" class="title-text">IPC Alternatives<a class="anchor title-text" href="#ipc-alternatives"> #</a>
</h2></div>









<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<p>Okay so now you have a list of tools in your toolbox to tackle
communicating between processes, so what should you use?</p>
<p>There is no hard answer, though this is the most interesting question.
Generally, we have retained pipes for legacy reasons. This means that we
only use them to redirect stdin, stdout, and stderr for the collection
of logs and similar programs. You may find processes trying to
communicate with unnamed or named pipes as well. Most of the time you
won’t be dealing with this interaction directly though.</p>
<p>Files are used almost all the time as a form of IPC. Hadoop is a great
example where processes will write to append-only tables and then other
processes will read from those tables. We generally use files under a
few cases. One case is if we want to save the intermediate results of an
operation to a file for future use. Another case is if putting it in
memory would cause an out of memory error. On Linux, file operations are
generally pretty cheap, so most programmers use it for larger
intermediate storage.</p>
<p>mmap is used for two scenarios. One is a <code class="language-plaintext highlighter-rouge">linear</code> or <code class="language-plaintext highlighter-rouge">near-linear</code> read
through of the file. Meaning, a program reads the file front to back or
back to front. The key is that the program doesn’t jump around too much.
Jumping around too much causes thrashing and loses all the benefits of
using mmap. The other usage of mmap is for direct memory inter-process
communication. This means that a program can store structures in a piece
of mmap’ed memory and share them between two processes. Python and Ruby
use this mapping all the time to utilize copy on write semantics.</p>
</div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="topics" class="title-text">Topics<a class="anchor title-text" href="#topics"> #</a>
</h2></div>



<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1"><ol>
  <li>
    <p>Virtual Memory</p>
  </li>
  <li>
    <p>Page Table</p>
  </li>
  <li>
    <p>MMU/TLB</p>
  </li>
  <li>
    <p>Address Translation</p>
  </li>
  <li>
    <p>Page Faults</p>
  </li>
  <li>
    <p>Frames/Pages</p>
  </li>
  <li>
    <p>Single-level vs multi-level page table</p>
  </li>
  <li>
    <p>Calculating offsets for multi-level page table</p>
  </li>
  <li>
    <p>Pipes</p>
  </li>
  <li>
    <p>Pipe read write ends</p>
  </li>
  <li>
    <p>Writing to a zero reader pipe</p>
  </li>
  <li>
    <p>Reading from a zero writer pipe</p>
  </li>
  <li>
    <p>Named pipe and Unnamed Pipes</p>
  </li>
  <li>
    <p>Buffer Size/Atomicity</p>
  </li>
  <li>
    <p>Scheduling Algorithms</p>
  </li>
  <li>
    <p>Measures of Efficiency</p>
  </li>
</ol></div></div></div>
</div></div>
<div class="pad"><div class="card">
<div class="title"><h2 id="questions" class="title-text">Questions<a class="anchor title-text" href="#questions"> #</a>
</h2></div>




<div class="container-fluid"><div class="row"><div class="content col-sm-11 .col-sm-offset-1">
<ol>
  <li>
    <p>What is virtual memory?</p>
  </li>
  <li>
    <p>What are the following and what is their purpose?</p>

    <ol>
      <li>
        <p>Translation Lookaside Buffer</p>
      </li>
      <li>
        <p>Physical Address</p>
      </li>
      <li>
        <p>Memory Management Unit. Multilevel page table. Frame number.
Page number and page offset.</p>
      </li>
      <li>
        <p>The dirty bit</p>
      </li>
      <li>
        <p>The NX Bit</p>
      </li>
    </ol>
  </li>
  <li>
    <p>What is a page table? How about a physical frame? Does a page always
need to point to a physical frame?</p>
  </li>
  <li>
    <p>What is a page fault? What are the types? When does it result in a
SEGFAULT?</p>
  </li>
  <li>
    <p>What are the advantages to a single-level page table? Disadvantages?
How about a multi-level table?</p>
  </li>
  <li>
    <p>What does a multi-leveled table look like in memory?</p>
  </li>
  <li>
    <p>How do you determine how many bits are used in the page offset?</p>
  </li>
  <li>
    <p>Given a 64-bit address space, 4kb pages and frames, and a 3 level
page table, how many bits are the Virtual page number 1, VPN2, VPN3
and the offset?</p>
  </li>
  <li>
    <p>What is a pipe? How do we create pipes?</p>
  </li>
  <li>
    <p>When is SIGPIPE delivered to a process?</p>
  </li>
  <li>
    <p>Under what conditions will calling read() on a pipe block? Under
what conditions will read() immediately return 0</p>
  </li>
  <li>
    <p>What is the difference between a named pipe and an unnamed pipe?</p>
  </li>
  <li>
    <p>Is a pipe thread-safe?</p>
  </li>
  <li>
    <p>Write a function that uses fseek and ftell to replace the middle
character of a file with an ’X’</p>
  </li>
  <li>
    <p>Write a function that creates a pipe and uses write to send 5 bytes,
“HELLO” to the pipe. Return the read file descriptor of the pipe.</p>
  </li>
  <li>
    <p>What happens when you mmap a file?</p>
  </li>
  <li>
    <p>Why is getting the file size with ftell not recommended? How should
you do it instead?</p>
  </li>
</ol>
<div id="refs" class="references">

<div id="ref-ricm">

“DEC Pdp-10 Ka10 Control Panel.” n.d. *RICM*. RICM.
<a href="http://www.ricomputermuseum.org/Home/interesting_computer_items/dec-pdp-ka10" class="fancy-link wiki-link">http://www.ricomputermuseum.org/Home/interesting_computer_items/dec-pdp-ka10</a>.

</div>

<div id="ref-ibm709">

(IBM), International Business Machines Corporation. August 1958. *IBM
709 Data Processing System Reference Manual*. International Business
Machines Corporation (IBM).
<a href="http://archive.computerhistory.org/resources/text/Fortran/102653991.05.01.acc.pdf" class="fancy-link wiki-link">http://archive.computerhistory.org/resources/text/Fortran/102653991.05.01.acc.pdf</a>.

</div>

<div id="ref-mmap_2018">

“Mmap.” 2018. *Mmap*. The Open Group.
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html" class="fancy-link wiki-link">http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html</a>.

</div>

</div>
</div></div></div>
</div></div>
</div>
            
            <div class="wrapper">
</div>
          </div>
          <div class="col-md-2 col-sm-1 col-xs-0"></div>
        </div>
        <!-- Mathjax takes a while to load so do a lazy load to so we can get accessibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script>

<!-- Bring in JQuery and Bootstrap -->
<script src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" crossorigin="anonymous"></script>
<!-- For table of content -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script src="/js/scroll.js"></script>
<footer class="">

<!-- Add another container at the bottom so there is some space there -->
<div class="container-fluid">
<div class="shadow"></div>

</div>

</footer>

      </div>
    </div>
  </div>
  <script type="application/javascript">
    var github_repo = "illinois-cs241/illinois-cs241.github.io";
    var github_path = "_coursebook/Ipc.md";
  </script>
</body>

</html>